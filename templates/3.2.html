{% extends 'base.html' %}
{% block head %}
<title>穿越时空的旅程 · GitBook</title>
<link href="3.3.html" rel="next"/>
<link href="3.1.html" rel="prev"/>
{% endblock %}
{% block body %}
<div class="book">
<div class="book-summary">
<div id="book-search-input" role="search">
<input placeholder="Type to search" type="text"/>
</div>
<nav role="navigation">
<ul class="summary">
<li class="chapter" data-level="1.1" data-path="index.html">
<a href="index.html">
            
                    
                    Introduction
            
                </a>
</li>
<li class="chapter" data-level="1.2" data-path="PA0.html">
<a href="PA0.html">
            
                    
                    PA0 - 世界诞生的前夜: 开发环境配置
            
                </a>
<ul class="articles">
<li class="chapter" data-level="1.2.1" data-path="0.1.html">
<a href="0.1.html">
            
                    
                    Installing GNU/Linux
            
                </a>
</li>
<li class="chapter" data-level="1.2.2" data-path="0.2.html">
<a href="0.2.html">
            
                    
                    First Exploration with GNU/Linux
            
                </a>
</li>
<li class="chapter" data-level="1.2.3" data-path="0.3.html">
<a href="0.3.html">
            
                    
                    Installing Tools
            
                </a>
</li>
<li class="chapter" data-level="1.2.4" data-path="0.4.html">
<a href="0.4.html">
            
                    
                    Configuring vim
            
                </a>
</li>
<li class="chapter" data-level="1.2.5" data-path="0.5.html">
<a href="0.5.html">
            
                    
                    More Exploration
            
                </a>
</li>
<li class="chapter" data-level="1.2.6" data-path="0.6.html">
<a href="0.6.html">
            
                    
                    Getting Source Code for PAs
            
                </a>
</li>
</ul>
</li>
<li class="chapter" data-level="1.3" data-path="PA1.html">
<a href="PA1.html">
            
                    
                    PA1 - 开天辟地的篇章: 最简单的计算机
            
                </a>
<ul class="articles">
<li class="chapter" data-level="1.3.1" data-path="1.1.html">
<a href="1.1.html">
            
                    
                    在开始愉快的PA之旅之前
            
                </a>
</li>
<li class="chapter" data-level="1.3.2" data-path="1.2.html">
<a href="1.2.html">
            
                    
                    开天辟地的篇章
            
                </a>
</li>
<li class="chapter" data-level="1.3.3" data-path="1.3.html">
<a href="1.3.html">
            
                    
                    RTFSC
            
                </a>
</li>
<li class="chapter" data-level="1.3.4" data-path="1.4.html">
<a href="1.4.html">
            
                    
                    基础设施
            
                </a>
</li>
<li class="chapter" data-level="1.3.5" data-path="1.5.html">
<a href="1.5.html">
            
                    
                    表达式求值
            
                </a>
</li>
<li class="chapter" data-level="1.3.6" data-path="1.6.html">
<a href="1.6.html">
            
                    
                    监视点
            
                </a>
</li>
<li class="chapter" data-level="1.3.7" data-path="1.7.html">
<a href="1.7.html">
            
                    
                    如何阅读手册
            
                </a>
</li>
</ul>
</li>
<li class="chapter" data-level="1.4" data-path="PA2.html">
<a href="PA2.html">
            
                    
                    PA2 - 简单复杂的机器: 冯诺依曼计算机系统
            
                </a>
<ul class="articles">
<li class="chapter" data-level="1.4.1" data-path="2.1.html">
<a href="2.1.html">
            
                    
                    不停计算的机器
            
                </a>
</li>
<li class="chapter" data-level="1.4.2" data-path="2.2.html">
<a href="2.2.html">
            
                    
                    RTFSC(2)
            
                </a>
</li>
<li class="chapter" data-level="1.4.3" data-path="2.3.html">
<a href="2.3.html">
            
                    
                    程序, 运行时环境与AM
            
                </a>
</li>
<li class="chapter" data-level="1.4.4" data-path="2.4.html">
<a href="2.4.html">
            
                    
                    基础设施(2)
            
                </a>
</li>
<li class="chapter" data-level="1.4.5" data-path="2.5.html">
<a href="2.5.html">
            
                    
                    输入输出
            
                </a>
</li>
</ul>
</li>
<li class="chapter" data-level="1.5" data-path="PA3.html">
<a href="PA3.html">
            
                    
                    PA3 - 穿越时空的旅程: 批处理系统
            
                </a>
<ul class="articles">
<li class="chapter" data-level="1.5.1" data-path="3.1.html">
<a href="3.1.html">
            
                    
                    最简单的操作系统
            
                </a>
</li>
<li class="chapter active" data-level="1.5.2" data-path="3.2.html">
<a href="3.2.html">
            
                    
                    穿越时空的旅程
            
                </a>
</li>
<li class="chapter" data-level="1.5.3" data-path="3.3.html">
<a href="3.3.html">
            
                    
                    用户程序和系统调用
            
                </a>
</li>
<li class="chapter" data-level="1.5.4" data-path="3.4.html">
<a href="3.4.html">
            
                    
                    文件系统
            
                </a>
</li>
<li class="chapter" data-level="1.5.5" data-path="3.5.html">
<a href="3.5.html">
            
                    
                    精彩纷呈的应用程序
            
                </a>
</li>
</ul>
</li>
<li class="chapter" data-level="1.6" data-path="PA4.html">
<a href="PA4.html">
            
                    
                    PA4 - 虚实交错的魔法: 分时多任务
            
                </a>
<ul class="articles">
<li class="chapter" data-level="1.6.1" data-path="4.1.html">
<a href="4.1.html">
            
                    
                    多道程序
            
                </a>
</li>
<li class="chapter" data-level="1.6.2" data-path="4.2.html">
<a href="4.2.html">
            
                    
                    虚实交错的魔法
            
                </a>
</li>
<li class="chapter" data-level="1.6.3" data-path="4.3.html">
<a href="4.3.html">
            
                    
                    超越容量的界限
            
                </a>
</li>
<li class="chapter" data-level="1.6.4" data-path="4.4.html">
<a href="4.4.html">
            
                    
                    来自外部的声音
            
                </a>
</li>
<li class="chapter" data-level="1.6.5" data-path="4.5.html">
<a href="4.5.html">
            
                    
                    编写不朽的传奇
            
                </a>
</li>
</ul>
</li>
<li class="chapter" data-level="1.7" data-path="blank.html">
<a href="blank.html">
            
                    
                    杂项
            
                </a>
<ul class="articles">
<li class="chapter" data-level="1.7.1" data-path="FAQ.html">
<a href="FAQ.html">
            
                    
                    常见问题(FAQ)
            
                </a>
</li>
<li class="chapter" data-level="1.7.2" data-path="why.html">
<a href="why.html">
            
                    
                    为什么要学习计算机系统基础
            
                </a>
</li>
<li class="chapter" data-level="1.7.3" data-path="linux.html">
<a href="linux.html">
            
                    
                    Linux入门教程
            
                </a>
</li>
<li class="chapter" data-level="1.7.4" data-path="man.html">
<a href="man.html">
            
                    
                    man入门教程
            
                </a>
</li>
<li class="chapter" data-level="1.7.5" data-path="git.html">
<a href="git.html">
            
                    
                    git入门教程
            
                </a>
</li>
<li class="chapter" data-level="1.7.6" data-path="nemu-isa-api.html">
<a href="nemu-isa-api.html">
            
                    
                    NEMU ISA相关API说明文档
            
                </a>
</li>
<li class="chapter" data-level="1.7.7" data-path="changelog.html">
<a href="changelog.html">
            
                    
                    更新日志
            
                </a>
</li>
<li class="chapter" data-level="1.7.8" data-path="i386-intro.html">
<a href="i386-intro.html">
            
                    
                    i386手册指令集阅读指南
            
                </a>
</li>
</ul>
</li>
<li class="divider"></li>
<li>
<a class="gitbook-link" href="https://www.gitbook.com" target="blank">
            Published with GitBook
        </a>
</li>
</ul>
</nav>
</div>
<div class="book-body">
<div class="body-inner">
<div class="book-header" role="navigation">
<!-- Title -->
<h1>
<i class="fa fa-circle-o-notch fa-spin"></i>
<a href=".">穿越时空的旅程</a>
</h1>
</div>
<div class="page-wrapper" role="main" tabindex="-1">
<div class="page-inner">
<div id="book-search-results">
<div class="search-noresults">
<section class="normal markdown-section">
<h2 id="穿越时空的旅程">穿越时空的旅程</h2>
<p>有了强大的硬件保护机制, 用户程序将无法把执行流切换到操作系统的任意代码了.
但为了实现最简单的操作系统, 硬件还需要提供一种可以限制入口的执行流切换方式.
这种方式就是自陷指令, 程序执行自陷指令之后, 就会陷入到操作系统预先设置好的跳转目标.
这个跳转目标也称为异常入口地址.</p>
<p>这一过程是ISA规范的一部分, 称为中断/异常响应机制.
大部分ISA并不区分CPU的异常和自陷, 甚至是将会在PA4最后介绍的硬件中断, 而是对它们进行统一的响应.
目前我们并未加入硬件中断, 因此先把这个机制简称为"异常响应机制"吧.</p>
<h3 id="x86">x86</h3>
<p>x86提供<code>int</code>指令作为自陷指令, 但其异常响应机制和其它ISA相比会复杂一些.
在x86中, 上述的异常入口地址是通过门描述符(Gate Descriptor)来指示的.
门描述符是一个8字节的结构体, 里面包含着不少细节的信息,
我们在NEMU中简化了门描述符的结构, 只保留存在位P和偏移量OFFSET:</p>
<pre><code>   31                23                15                7                0
  +-----------------+-----------------+---+-------------------------------+
  |           OFFSET 31..16           | P |          Don't care           |4
  +-----------------------------------+---+-------------------------------+
  |             Don't care            |           OFFSET 15..0            |0
  +-----------------+-----------------+-----------------+-----------------+
</code></pre><p>P位来用表示这一个门描述符是否有效, OFFSET用来指示异常入口地址.
有了门描述符, 用户程序就只能跳转到门描述符中OFFSET所指定的位置,
再也不能随心所欲地跳转到操作系统的任意代码了.</p>
<p>为了方便管理各个门描述符, x86把内存中的某一段数据专门解释成一个数组,
叫IDT(Interrupt Descriptor Table, 中断描述符表), 数组的一个元素就是一个门描述符.
为了从数组中找到一个门描述符, 我们还需要一个索引.
对于CPU异常来说, 这个索引由CPU内部产生(例如除零异常为0号异常),或者由<code>int</code>指令给出(例如<code>int $0x80</code>).
最后, 为了在内存中找到IDT, x86使用IDTR寄存器来存放IDT的首地址和长度.
操作系统的代码事先把IDT准备好, 然后执行一条特殊的指令<code>lidt</code>,
来在IDTR中设置好IDT的首地址和长度, 这一异常响应机制就可以正常工作了.
现在是万事俱备, 等到程序执行自陷指令或者触发异常的时候, CPU就会按照设定好的IDT跳转到异常入口地址:</p>
<pre><code>           |               |
           |   Entry Point |&lt;----+
           |               |     |
           |               |     |
           |               |     |
           +---------------+     |
           |               |     |
           |               |     |
           |               |     |
           +---------------+     |
           |offset |       |     |
           |-------+-------|     |
           |       | offset|-----+
  index---&gt;+---------------+
           |               |
           |Gate Descriptor|
           |               |
    IDT---&gt;+---------------+
           |               |
           |               |
</code></pre><p>不过, 我们将来还是有可能需要返回到程序的当前状态来继续执行的,
比如通过<code>int3</code>触发的断点异常.
这意味着, 我们需要在进行响应异常的时候保存好程序当前的状态.
于是, 触发异常后硬件的响应过程如下:</p>
<ol>
<li>从IDTR中读出IDT的首地址</li>
<li>根据异常号在IDT中进行索引, 找到一个门描述符</li>
<li>将门描述符中的offset域组合成异常入口地址</li>
<li>依次将eflags, cs(代码段寄存器), eip(也就是PC)寄存器的值压栈</li>
<li>跳转到异常入口地址</li>
</ol>
<p>在计算机和谐社会中, 大部分门描述符都不能让用户进程随意使用,
否则恶意程序就可以通过<code>int</code>指令欺骗操作系统.
例如恶意程序执行<code>int $0x2</code>来谎报电源掉电, 扰乱其它进程的正常运行.
因此执行<code>int</code>指令也需要进行特权级检查, 但PA中就不实现这一保护机制了,
具体的检查规则我们也就不展开讨论了, 需要了解时RTFM即可.</p>
<h3 id="mips32">mips32</h3>
<p>mips32提供<code>syscall</code>指令作为自陷指令, 它的工作过程十分简单.
mips32约定, 上述的异常入口地址总是<code>0x80000180</code>.
为了保存程序当前的状态, mips32提供了一些特殊的系统寄存器,
这些寄存器位于0号协处理器(Co-Processor 0)中, 因此也称CP0寄存器.
在PA中, 我们只使用如下3个CP0寄存器:</p>
<ul>
<li>epc寄存器 - 存放触发异常的PC</li>
<li>status寄存器 - 存放处理器的状态</li>
<li>cause寄存器 - 存放触发异常的原因</li>
</ul>
<p>mips32触发异常后硬件的响应过程如下:</p>
<ol>
<li>将当前PC值保存到epc寄存器</li>
<li>在cause寄存器中设置异常号</li>
<li>在status寄存器中设置异常标志, 使处理器进入内核态</li>
<li>跳转到<code>0x80000180</code></li>
</ol>
<h3 id="riscv32">riscv32</h3>
<p>riscv32提供<code>ecall</code>指令作为自陷指令, 并提供一个mtvec寄存器来存放异常入口地址.
为了保存程序当前的状态, riscv32提供了一些特殊的系统寄存器, 叫控制状态寄存器(CSR寄存器).
在PA中, 我们只使用如下3个CSR寄存器:</p>
<ul>
<li>mepc寄存器 - 存放触发异常的PC</li>
<li>mstatus寄存器 - 存放处理器的状态</li>
<li>mcause寄存器 - 存放触发异常的原因</li>
</ul>
<p>riscv32触发异常后硬件的响应过程如下:</p>
<ol>
<li>将当前PC值保存到mepc寄存器</li>
<li>在mcause寄存器中设置异常号</li>
<li>从mtvec寄存器中取出异常入口地址</li>
<li>跳转到异常入口地址</li>
</ol>
<hr/>
<p>需要注意的是, 上述保存程序状态以及跳转到异常入口地址的工作,
都是硬件自动完成的, 不需要程序员编写指令来完成相应的内容.
事实上, 这只是一个简化后的过程, 在真实的计算机上还要处理很多细节问题,
比如x86和riscv32的特权级切换等, 在这里我们就不深究了.
ISA手册中还记录了处理器对中断号和异常号的分配情况,
并列出了各种异常的详细解释, 需要了解的时候可以进行查阅.</p>
<div class="panel panel-info"><div class="panel-heading"><h5 class="panel-title" id="特殊的原因-建议二周目思考"><i class="fa fa-question-circle"></i> 特殊的原因? (建议二周目思考)</h5></div><div class="panel-body"><p>这些程序状态(x86的eflags, cs, eip; mips32的epc, status, cause;
riscv32的mepc, mstatus, mcause)必须由硬件来保存吗? 能否通过软件来保存? 为什么?</p></div></div>
<p>由于异常入口地址是硬件和操作系统约定好的, 接下来的处理过程将会由操作系统来接管,
操作系统将视情况决定是否终止当前程序的运行(例如触发段错误的程序将会被杀死).
若决定无需杀死当前程序, 等到异常处理结束之后, 就根据之前保存的信息恢复程序的状态,
并从异常处理过程中返回到程序触发异常之前的状态.
具体地:</p>
<ul>
<li>x86通过<code>iret</code>指令从异常处理过程中返回,
它将栈顶的三个元素来依次解释成eip, cs, eflags, 并恢复它们.</li>
<li>mips32通过<code>eret</code>指令从异常处理过程中返回,
它将清除status寄存器中的异常标志, 并根据epc寄存器恢复PC.</li>
<li>riscv32通过<code>mret</code>指令从异常处理过程中返回, 它将根据mepc寄存器恢复PC.</li>
</ul>
<h3 id="状态机视角下的异常响应机制">状态机视角下的异常响应机制</h3>
<p>程序是个<code>S = &lt;R, M&gt;</code>的状态机, 我们之前已经讨论过在TRM和IOE中这个状态机的具体行为.
如果要给计算机添加异常响应机制, 我们又应该如何对这个状态机进行扩充呢?</p>
<p>首先当然是对<code>R</code>的扩充, 除了PC和通用寄存器之外, 还需要添加上文提到的一些特殊寄存器.
我们不妨把这些寄存器称为系统寄存器(System Register),
因为这些寄存器的作用都是和系统功能相关的, 平时进行计算的时候不会使用.
扩充之后的寄存器可以表示为<code>R = {GPR, PC, SR}</code>.
异常响应机制和内存无关, 因此我们无需对<code>M</code>的含义进行修改.</p>
<p>对状态转移的扩充就比较有趣了. 我们之前都是认为程序执行的每一条指令都会成功,
从而状态机会根据指令的语义进行状态转移.
添加异常响应机制之后, 我们允许一条指令的执行会"失败".
为了描述指令执行失败的行为, 我们可以假设CPU有一条虚构的指令<code>raise_intr</code>,
执行这条虚构指令的行为就是上文提到的异常响应过程.
显然, 这一行为是可以用状态机视角来描述的, 例如在riscv32中可以表示成:</p>
<pre><code>SR[mepc] &lt;- PC
SR[mcause] &lt;- 一个描述失败原因的号码
PC &lt;- SR[mtvec]
</code></pre><p>有了这条虚构的指令, 我们就可以从状态机视角来理解异常响应的行为了:
如果一条指令执行成功, 其行为和之前介绍的TRM与IOE相同;
如果一条指令执行失败, 其行为等价于执行了虚构的<code>raise_intr</code>指令.</p>
<p>那么, "一条指令的执行是否会失败"这件事是不是确定性的呢?
显然这取决于"失败"的定义, 例如除0就是"除法指令的第二个操作数为0",
非法指令可以定义成"不属于ISA手册描述范围的指令",
而自陷指令可以认为是一种特殊的无条件失败.
不同的ISA手册都有各自对"失败"的定义, 例如RISC-V手册就不认为除0是一种失败,
因此即使除数为0, 在RISC-V处理器中这条指令也会按照指令手册的描述来执行.</p>
<p>事实上, 我们可以把这些失败的条件表示成一个函数<code>fex: S -&gt; {0, 1}</code>,
给定状态机的任意状态<code>S</code>, <code>fex(S)</code>都可以唯一表示当前PC指向的指令是否可以成功执行.
于是, 给计算机加入异常响应机制并不会增加系统的不确定性,
这大大降低了我们理解异常响应机制的难度, 同时也让调试不至于太困难:
一个程序运行多次, 还是会在相同的地方抛出相同的异常, 从而进行相同的状态转移
(IOE的输入指令会引入一些不确定性, 但目前还是在我们能控制的范围内).</p>
<p><img alt="cte" src="images/cte.png"/></p>
<p>最后, 异常响应机制的加入还伴随着一些系统指令的添加,
例如x86的<code>lidt</code>, <code>iret</code>, riscv32的<code>csrrw</code>, <code>mret</code>等.
这些指令除了用于专门对状态机中的<code>SR</code>进行操作之外, 它们本质上和TRM的计算指令没有太大区别,
因此它们的行为也不难理解.</p>
<h2 id="将上下文管理抽象成cte">将上下文管理抽象成CTE</h2>
<p>我们刚才提到了程序的状态, 在操作系统中有一个等价的术语, 叫"上下文".
因此, 硬件提供的上述在操作系统和用户程序之间切换执行流的功能,
在操作系统看来, 都可以划入上下文管理的一部分.</p>
<p>与IOE一样, 上下文管理的具体实现也是架构相关的:
例如上文提到, x86/mips32/riscv32中分别通过<code>int</code>/<code>syscall</code>/<code>ecall</code>指令来进行自陷,
<code>native</code>中甚至可以通过一些神奇的库函数来模拟相应的功能;
而上下文的具体内容, 在不同的架构上也显然不一样(比如寄存器就已经不一样了).
于是, 我们可以将上下文管理的功能划入到AM的一类新的API中, 名字叫CTE(ConText Extension).</p>
<p>接下来的问题是, 如何将不同架构的上下文管理功能抽象成统一的API呢?
换句话说, 我们需要思考, 操作系统的处理过程其实需要哪些信息?</p>
<ul>
<li>首先当然是引发这次执行流切换的原因, 是程序除0, 非法指令, 还是触发断点,
又或者是程序自愿陷入操作系统? 根据不同的原因, 操作系统都会进行不同的处理.</li>
<li>然后就是程序的上下文了, 在处理过程中, 操作系统可能会读出上下文中的一些寄存器,
根据它们的信息来进行进一步的处理.
例如操作系统读出PC所指向的非法指令, 看看其是否能被模拟执行.
事实上, 通过这些上下文, 操作系统还能实现一些神奇的功能, 你将会在PA4中了解更详细的信息.</li>
</ul>
<div class="panel panel-info"><div class="panel-heading"><h5 class="panel-title" id="用软件模拟指令"><i class="fa fa-comment-o"></i> 用软件模拟指令</h5></div><div class="panel-body"><p>在一些嵌入式场景中, 处理器对低功耗的要求非常严格, 很多时候都会去掉浮点处理单元FPU来节省功耗.
这时候如果软件要执行一条浮点指令, 处理器就会抛出一个非法指令的异常.
有了异常响应机制, 我们就可以在异常处理的过程中模拟这条非法指令的执行了,
原理和PA2中的指令执行过程非常类似.
在不带FPU的各种处理器中, 都可以通过这种方式来执行浮点指令.</p></div></div>
<!-- -->
<div class="panel panel-info"><div class="panel-heading"><h5 class="panel-title" id="在am中执行浮点指令是ub"><i class="fa fa-comment-o"></i> 在AM中执行浮点指令是UB</h5></div><div class="panel-body"><p>换句话说, AM的运行时环境不支持浮点数. 这听上去太暴力了.
之所以这样决定, 是因为IEEE 754是个工业级标准,
为了形式化逻辑上的soundness和completeness, 标准里面可能会有各种奇怪的设定,
例如不同的舍入方式, inf和nan的引入等等, 作为教学其实没有必要去理解它们的所有细节;
但如果要去实现一个正确的FPU, 你就没法摆脱这些细节了.</p><p>和PA2中的定点指令不同, 浮点指令在PA中用到的场合比较少, 而且我们有别的方式可以绕开,
所以就怎么简单怎么来了, 于是就UB吧.
当然, 如果你感兴趣, 你也可以考虑实现一个简化版的FPU.
毕竟是UB, 如果你的FPU行为正确, 也不算违反规定.</p></div></div>
<!-- -->
<div class="panel panel-info"><div class="panel-heading"><h5 class="panel-title" id="另一个ub"><i class="fa fa-comment-o"></i> 另一个UB</h5></div><div class="panel-body"><p>另一种你可能会碰到的UB是栈溢出, 对, 就是stackoverflow的那个.
检测栈溢出需要一个更强大的运行时环境, AM肯定是无能为力了, 于是就UB吧.</p><p>不过, AM究竟给程序提供了多大的栈空间呢?
事实上, 如果你在PA2的时候尝试努力了解每一处细节, 你已经知道这个问题的答案了;
如果你没有, 你需要反思一下自己了, 还是认真RTFSC吧.</p></div></div>
<p>所以, 我们只要把这两点信息抽象成一种统一的表示方式, 就可以定义出CTE的API了.
对于切换原因, 我们只需要定义一种统一的描述方式即可.
CTE定义了名为"事件"的如下数据结构(见<code>abstract-machine/am/include/am.h</code>):</p>
<pre><code class="lang-c"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> Event {
  <span class="hljs-keyword">enum</span> { ... } event;
  <span class="hljs-keyword">uintptr_t</span> cause, ref;
  <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *msg;
} Event;
</code></pre>
<p>其中<code>event</code>表示事件编号, <code>cause</code>和<code>ref</code>是一些描述事件的补充信息,
<code>msg</code>是事件信息字符串, 我们在PA中只会用到<code>event</code>.
然后, 我们只要定义一些统一的事件编号(上述枚举常量), 让每个架构在实现各自的CTE API时,
都统一通过上述结构体来描述执行流切换的原因, 就可以实现切换原因的抽象了.</p>
<p>对于上下文, 我们只能将描述上下文的结构体类型名统一成<code>Context</code>,
至于其中的具体内容, 就无法进一步进行抽象了.
这主要是因为不同架构之间上下文信息的差异过大, 比如mips32有32个通用寄存器,
就从这一点来看, mips32和x86的<code>Context</code>注定是无法抽象成完全统一的结构的.
所以在AM中, <code>Context</code>的具体成员也是由不同的架构自己定义的,
比如<code>x86-nemu</code>的<code>Context</code>结构体在<code>abstract-machine/am/include/arch/x86-nemu.h</code>中定义.
因此, 在操作系统中对<code>Context</code>成员的直接引用,
都属于架构相关的行为, 会损坏操作系统的可移植性.
不过大多数情况下, 操作系统并不需要单独访问<code>Context</code>结构中的成员.
CTE也提供了一些的接口, 来让操作系统在必要的时候访问它们,
从而保证操作系统的相关代码与架构无关.</p>
<p>最后还有另外两个统一的API:</p>
<ul>
<li><code>bool cte_init(Context* (*handler)(Event ev, Context *ctx))</code>用于进行CTE相关的初始化操作.
其中它还接受一个来自操作系统的事件处理回调函数的指针, 当发生事件时,
CTE将会把事件和相关的上下文作为参数, 来调用这个回调函数, 交由操作系统进行后续处理.</li>
<li><code>void yield()</code>用于进行自陷操作, 会触发一个编号为<code>EVENT_YIELD</code>事件.
不同的ISA会使用不同的自陷指令来触发自陷操作, 具体实现请RTFSC.</li>
</ul>
<p>CTE中还有其它的API, 目前不使用, 故暂不介绍它们.</p>
<p>接下来, 我们尝试通过<code>am-tests</code>中的<code>yield test</code>测试触发一次自陷操作, 来梳理过程中的细节.
这个测试还支持时钟中断和外部中断, 但这还需要硬件提供中断相关的功能, 目前我们暂时不关心它们.</p>
<div class="panel panel-danger"><div class="panel-heading"><h5 class="panel-title" id="更新am-kernels"><i class="fa fa-exclamation"></i> 更新am-kernels</h5></div><div class="panel-body"><p>我们在2023年10月3日15:35:00更新了<code>yield test</code>的代码.
如果你在此时间前获取<code>am-kernels</code>的代码, 请通过以下命令获取更新后的代码:</p><pre><code class="lang-bash"><span class="hljs-built_in">cd</span> am-kernels
git pull origin master
</code></pre></div></div>
<h3 id="设置异常入口地址">设置异常入口地址</h3>
<p>在触发自陷操作前, 首先需要按照ISA的约定来设置异常入口地址, 将来切换执行流时才能跳转到正确的异常入口.
这显然是架构相关的行为, 因此我们把这一行为放入CTE中, 而不是让<code>am-tests</code>直接来设置异常入口地址.
当我们选择<code>yield test</code>时, <code>am-tests</code>会通过<code>cte_init()</code>函数对CTE进行初始化, 其中包含一些简单的宏展开代码.
这最终会调用位于<code>abstract-machine/am/src/$ISA/nemu/cte.c</code>中的<code>cte_init()</code>函数.
<code>cte_init()</code>函数会做两件事情, 第一件就是设置异常入口地址:</p>
<ul>
<li>对x86来说, 就是要准备一个有意义的IDT<ol>
<li>代码定义了一个结构体数组<code>idt</code>, 它的每一个元素是一个门描述符结构体</li>
<li>在相应的数组元素中填写有意义的门描述符, 例如编号为<code>0x81</code>的门描述符中就包含自陷操作的入口地址.
需要注意的是, 框架代码中还是填写了完整的门描述符(包括上文中提到的don't care的域),
这主要是为了进行DiffTest时让KVM也能跳转到正确的入口地址.
KVM实现了完整的x86异常响应机制, 如果只填写简化版的门描述符, 代码就无法在其中正确运行.
但我们无需了解其中的细节, 只需要知道代码已经填写了正确的门描述符即可.</li>
<li>通过<code>lidt</code>指令在IDTR中设置<code>idt</code>的首地址和长度</li>
</ol>
</li>
<li>对于mips32来说, 由于异常入口地址是固定在<code>0x80000180</code>,
因此我们需要在<code>0x80000180</code>放置一条无条件跳转指令,
使得这一指令的跳转目标是我们希望的真正的异常入口地址即可.</li>
<li>对于riscv32来说, 直接将异常入口地址设置到mtvec寄存器中即可.</li>
</ul>
<p><code>cte_init()</code>函数做的第二件事是注册一个事件处理回调函数,
这个回调函数由<code>yield test</code>提供, 更多信息会在下文进行介绍.</p>
<h3 id="触发自陷操作">触发自陷操作</h3>
<p>从<code>cte_init()</code>函数返回后, <code>yield test</code>将会调用测试主体函数<code>hello_intr()</code>,
首先输出一些信息, 然后通过<code>io_read(AM_INPUT_CONFIG)</code>启动输入设备,
不过在NEMU中, 这一启动并无实质性操作.
接下来<code>hello_intr()</code>将通过<code>iset(1)</code>打开中断,
不过我们目前还没有实现中断相关的功能, 因此同样可以忽略这部分的代码.
最后<code>hello_intr()</code>将进入测试主循环: 代码将不断调用<code>yield()</code>进行自陷操作,
为了防止调用频率过高导致输出过快, 测试主循环中还添加了一个空循环用于空转.</p>
<p>为了支撑自陷操作, 同时测试异常入口地址是否已经设置正确, 你需要在NEMU中实现<code>isa_raise_intr()</code>函数
(在<code>nemu/src/isa/$ISA/system/intr.c</code>中定义)来模拟上文提到的异常响应机制.</p>
<p>需要注意的是:</p>
<ul>
<li>PA不涉及特权级的切换, RTFM的时候你不需要关心和特权级切换相关的内容.</li>
<li>你需要在自陷指令的实现中调用<code>isa_raise_intr()</code>,
而不要把异常响应机制的代码放在自陷指令的helper函数中实现,
因为在后面我们会再次用到<code>isa_raise_intr()</code>函数.</li>
<li>如果你选择的是x86, 通过IDTR中的地址对IDT进行索引的时候, 需要使用<code>vaddr_read()</code>.</li>
</ul>
<div class="panel panel-warning"><div class="panel-heading"><h5 class="panel-title" id="实现异常响应机制"><i class="fa fa-edit"></i> 实现异常响应机制</h5></div><div class="panel-body"><p>你需要实现上文提到的新指令, 并实现<code>isa_raise_intr()</code>函数.
然后阅读<code>cte_init()</code>的代码, 找出相应的异常入口地址.</p><p>如果你选择mips32和riscv32, 你会发现status/mstatus寄存器中有非常多状态位,
不过目前完全不实现这些状态位的功能也不影响程序的执行,
因此目前只需要将status/mstatus寄存器看成一个只用于存放32位数据的寄存器即可.</p><p>实现后, 重新运行<code>yield test</code>, 如果你发现NEMU确实跳转到你找到的异常入口地址,
说明你的实现正确(NEMU也可能因为触发了未实现指令而终止运行).</p></div></div>
<!-- -->
<div class="panel panel-info"><div class="panel-heading"><h5 class="panel-title" id="让difftest支持异常响应机制"><i class="fa fa-edit"></i> 让DiffTest支持异常响应机制</h5></div><div class="panel-body"><p>为了让DiffTest机制正确工作, 你需要</p><ul>
<li>针对x86:<ul>
<li>NEMU中不实现分段机制, 没有cs寄存器的概念. 但为了顺利进行DiffTest,
你还是需要在cpu结构体中添加一个cs寄存器, 并在将其初始化为<code>8</code>.</li>
<li>由于x86的异常响应机制需要对eflags进行压栈, 你还需要将eflags初始化为<code>0x2</code>.</li>
</ul>
</li>
<li>针对riscv32, 你需要将mstatus初始化为<code>0x1800</code>.</li>
<li>针对riscv64, 你需要将mstatus初始化为<code>0xa00001800</code>.</li>
</ul></div></div>
<h3 id="保存上下文">保存上下文</h3>
<p>成功跳转到异常入口地址之后, 我们就要在软件上开始真正的异常处理过程了.
但是, 进行异常处理的时候不可避免地需要用到通用寄存器,
然而看看现在的通用寄存器, 里面存放的都是执行流切换之前的内容.
这些内容也是上下文的一部分, 如果不保存就覆盖它们, 将来就无法恢复这一上下文了.
但通常硬件并不负责保存它们, 因此需要通过软件代码来保存它们的值.
x86提供了<code>pusha</code>指令, 用于把通用寄存器的值压栈;
而mips32和riscv32则通过<code>sw</code>指令将各个通用寄存器依次压栈.</p>
<p>除了通用寄存器之外, 上下文还包括:</p>
<ul>
<li>触发异常时的PC和处理器状态.
对于x86来说就是eflags, cs和eip, x86的异常响应机制已经将它们保存在堆栈上了;
对于mips32和riscv32来说, 就是epc/mepc和status/mstatus寄存器,
异常响应机制把它们保存在相应的系统寄存器中, 我们还需要将它们从系统寄存器中读出,
然后保存在堆栈上.</li>
<li>异常号. 对于x86, 异常号由软件保存; 而对于mips32和riscv32,
异常号已经由硬件保存在cause/mcause寄存器中, 我们还需要将其保存在堆栈上.</li>
<li>地址空间. 这是为PA4准备的, 在x86中对应的是<code>CR3</code>寄存器, 代码通过一条<code>pushl $0</code>指令在堆栈上占位,
mips32和riscv32则是将地址空间信息与0号寄存器共用存储空间,
反正0号寄存器的值总是0, 也不需要保存和恢复.
不过目前我们暂时不使用地址空间信息, 你目前可以忽略它们的含义.</li>
</ul>
<div class="panel panel-info"><div class="panel-heading"><h5 class="panel-title" id="异常号的保存"><i class="fa fa-question-circle"></i> 异常号的保存</h5></div><div class="panel-body"><p>x86通过软件来保存异常号, 没有类似cause的寄存器.
mips32和riscv32也可以这样吗? 为什么?</p></div></div>
<p>于是, 这些内容构成了完整的上下文信息, 异常处理过程可以根据上下文来诊断并进行处理,
同时, 将来恢复上下文的时候也需要这些信息.</p>
<div class="panel panel-info"><div class="panel-heading"><h5 class="panel-title" id="对比异常处理与函数调用"><i class="fa fa-question-circle"></i> 对比异常处理与函数调用</h5></div><div class="panel-body"><p>我们知道进行函数调用的时候也需要保存调用者的状态:
返回地址, 以及calling convention中需要调用者保存的寄存器.
而CTE在保存上下文的时候却要保存更多的信息.
尝试对比它们, 并思考两者保存信息不同是什么原因造成的.</p></div></div>
<p>接下来代码会调用C函数<code>__am_irq_handle()</code>(在<code>abstract-machine/am/src/$ISA/nemu/cte.c</code>中定义),
来进行异常的处理.</p>
<div class="panel panel-info"><div class="panel-heading"><h5 class="panel-title" id="诡异的x86代码"><i class="fa fa-question-circle"></i> 诡异的x86代码</h5></div><div class="panel-body"><p>x86的<code>trap.S</code>中有一行<code>pushl %esp</code>的代码, 乍看之下其行为十分诡异.
你能结合前后的代码理解它的行为吗?
Hint: 程序是个状态机.</p></div></div>
<!-- -->
<div class="panel panel-warning"><div class="panel-heading"><h5 class="panel-title" id="重新组织context结构体"><i class="fa fa-edit"></i> 重新组织Context结构体</h5></div><div class="panel-body"><p>你的任务如下:</p><ul>
<li>实现这一过程中的新指令, 详情请RTFM.</li>
<li>理解上下文形成的过程并RTFSC, 然后重新组织<code>abstract-machine/am/include/arch/$ISA-nemu.h</code>
中定义的<code>Context</code>结构体的成员, 使得这些成员的定义顺序和
<code>abstract-machine/am/src/$ISA/nemu/trap.S</code>中构造的上下文保持一致.</li>
</ul><p>需要注意的是, 虽然我们目前暂时不使用上文提到的地址空间信息,
但你在重新组织<code>Context</code>结构体时仍然需要正确地处理地址空间信息的位置,
否则你可能会在PA4中遇到难以理解的错误.</p><p>实现之后, 你可以在<code>__am_irq_handle()</code>中通过<code>printf</code>输出上下文<code>c</code>的内容,
然后通过简易调试器观察触发自陷时的寄存器状态, 从而检查你的<code>Context</code>实现是否正确.</p></div></div>
<!-- -->
<div class="panel panel-success"><div class="panel-heading"><h5 class="panel-title" id="给一些提示吧"><i class="fa fa-lightbulb-o"></i> 给一些提示吧</h5></div><div class="panel-body"><p>"实现新指令"没什么好说的, 你已经在PA2中实现了很多指令了.
"重新组织结构体"是一个非常有趣的题目, 如果你不知道要做什么, 不妨从读懂题目开始.
题目大概的意思就是, 根据<code>trap.S</code>里面的内容, 来定义<code>$ISA-nemu.h</code>里面的一个结构体.
<code>trap.S</code>明显是汇编代码, 而<code>$ISA-nemu.h</code>里面则是一个用C语言定义的结构体.
汇编代码和C语言... 等等, 你好像想起了ICS课本的某些内容...</p></div></div>
<!-- -->
<div class="panel panel-danger"><div class="panel-heading"><h5 class="panel-title" id="我乱改一通-居然过了-嘿嘿嘿"><i class="fa fa-bullhorn"></i> 我乱改一通, 居然过了, 嘿嘿嘿</h5></div><div class="panel-body"><p>如果你还抱着这种侥幸心态, 你在PA3中会过得非常痛苦.
事实上, "明白如何正确重新组织结构体"是PA3中非常重要的内容.
所以我们还是加一道必答题吧.</p></div></div>
<!-- -->
<div class="panel panel-warning"><div class="panel-heading"><h5 class="panel-title" id="必答题需要在实验报告中回答---理解上下文结构体的前世今生"><i class="fa fa-edit"></i> 必答题(需要在实验报告中回答) - 理解上下文结构体的前世今生</h5></div><div class="panel-body"><p>你会在<code>__am_irq_handle()</code>中看到有一个上下文结构指针<code>c</code>,
<code>c</code>指向的上下文结构究竟在哪里? 这个上下文结构又是怎么来的?
具体地, 这个上下文结构有很多成员, 每一个成员究竟在哪里赋值的?
<code>$ISA-nemu.h</code>, <code>trap.S</code>, 上述讲义文字, 以及你刚刚在NEMU中实现的新指令,
这四部分内容又有什么联系?</p><p>如果你不是脑袋足够灵光, 还是不要眼睁睁地盯着代码看了,
理解程序的细节行为还是要从状态机视角入手.</p></div></div>
<h3 id="事件分发">事件分发</h3>
<p><code>__am_irq_handle()</code>的代码会把执行流切换的原因打包成事件,
然后调用在<code>cte_init()</code>中注册的事件处理回调函数, 将事件交给<code>yield test</code>来处理.
在<code>yield test</code>中, 这一回调函数是<code>am-kernels/tests/am-tests/src/tests/intr.c</code>中的<code>simple_trap()</code>函数.
<code>simple_trap()</code>函数会根据事件类型再次进行分发.
不过我们在这里会触发一个未处理的事件:</p>
<pre><code>AM Panic: Unhandled event @ am-kernels/tests/am-tests/src/tests/intr.c:12
</code></pre><p>这是因为CTE的<code>__am_irq_handle()</code>函数并未正确识别出自陷事件.
根据<code>yield()</code>的定义, <code>__am_irq_handle()</code>函数需要将自陷事件打包成编号为<code>EVENT_YIELD</code>的事件.</p>
<div class="panel panel-warning"><div class="panel-heading"><h5 class="panel-title" id="识别自陷事件"><i class="fa fa-edit"></i> 识别自陷事件</h5></div><div class="panel-body"><p>你需要在<code>__am_irq_handle()</code>中通过异常号识别出自陷异常, 并打包成编号为<code>EVENT_YIELD</code>的自陷事件.
重新运行<code>yield test</code>, 如果你的实现正确, 你会看到识别到自陷事件之后输出一个字符<code>y</code>.</p></div></div>
<h3 id="恢复上下文">恢复上下文</h3>
<p>代码将会一路返回到<code>trap.S</code>的<code>__am_asm_trap()</code>中, 接下来的事情就是恢复程序的上下文.
<code>__am_asm_trap()</code>将根据之前保存的上下文内容, 恢复程序的状态,
最后执行"异常返回指令"返回到程序触发异常之前的状态.</p>
<p>不过这里需要注意之前自陷指令保存的PC, 对于x86的<code>int</code>指令,
保存的是指向其下一条指令的PC, 这有点像函数调用;
而对于mips32的<code>syscall</code>和riscv32的<code>ecall</code>, 保存的是自陷指令的PC,
因此软件需要在适当的地方对保存的PC加上4, 使得将来返回到自陷指令的下一条指令.</p>
<div class="panel panel-info"><div class="panel-heading"><h5 class="panel-title" id="从加4操作看cisc和risc"><i class="fa fa-question-circle"></i> 从加4操作看CISC和RISC</h5></div><div class="panel-body"><p>事实上, 自陷只是其中一种异常类型.
有一种故障类异常, 它们返回的PC和触发异常的PC是同一个, 例如缺页异常,
在系统将故障排除后, 将会重新执行相同的指令进行重试, 因此异常返回的PC无需加4.
所以根据异常类型的不同, 有时候需要加4, 有时候则不需要加.</p><p>这时候, 我们就可以考虑这样的一个问题了:
决定要不要加4的, 是硬件还是软件呢?
CISC和RISC的做法正好相反, CISC都交给硬件来做, 而RISC则交给软件来做.
思考一下, 这两种方案各有什么取舍? 你认为哪种更合理呢? 为什么?</p></div></div>
<p>代码最后会返回到<code>yield test</code>触发自陷的代码位置, 然后继续执行.
在它看来, 这次时空之旅就好像没有发生过一样.</p>
<div class="panel panel-warning"><div class="panel-heading"><h5 class="panel-title" id="恢复上下文"><i class="fa fa-edit"></i> 恢复上下文</h5></div><div class="panel-body"><p>你需要实现这一过程中的新指令. 重新运行<code>yield test</code>.
如果你的实现正确, <code>yield test</code>将不断输出<code>y</code>.</p></div></div>
<!-- -->
<div class="panel panel-warning"><div class="panel-heading"><h5 class="panel-title" id="必答题需要在实验报告中回答---理解穿越时空的旅程"><i class="fa fa-edit"></i> 必答题(需要在实验报告中回答) - 理解穿越时空的旅程</h5></div><div class="panel-body"><p>从<code>yield test</code>调用<code>yield()</code>开始, 到从<code>yield()</code>返回的期间, 这一趟旅程具体经历了什么?
软(AM, <code>yield test</code>)硬(NEMU)件是如何相互协助来完成这趟旅程的? 你需要解释这一过程中的每一处细节,
包括涉及的每一行汇编代码/C代码的行为, 尤其是一些比较关键的指令/变量.
事实上, 上文的必答题"理解上下文结构体的前世今生"已经涵盖了这趟旅程中的一部分,
你可以把它的回答包含进来.</p><p>别被"每一行代码"吓到了, 这个过程也就大约50行代码, 要完全理解透彻并不是不可能的.
我们之所以设置这道必答题, 是为了强迫你理解清楚这个过程中的每一处细节.
这一理解是如此重要, 以至于如果你缺少它, 接下来你面对bug几乎是束手无策.</p></div></div>
<!-- -->
<div class="panel panel-info"><div class="panel-heading"><h5 class="panel-title" id="mips32延迟槽和异常"><i class="fa fa-question-circle"></i> mips32延迟槽和异常</h5></div><div class="panel-body"><p>我们在PA2中提到, 标准的mips32处理器采用了分支延迟槽技术.
思考一下, 如果标准的mips32处理器在执行延迟槽指令的时候触发了异常,
从异常返回之后可能会造成什么问题? 该如何解决?
尝试RTFM对比你的解决方案.</p></div></div>
<h3 id="异常处理的踪迹---etrace">异常处理的踪迹 - etrace</h3>
<p>处理器抛出异常也可以反映程序执行的行为, 因此我们也可以记录异常处理的踪迹(exception trace).
你也许认为在CTE中通过<code>printf()</code>输出信息也可以达到类似的效果,
但这一方案和在NEMU中实现的etrace还是有如下区别:</p>
<ul>
<li>打开etrace不改变程序的行为(对程序来说是非侵入式的): 你将来可能会遇到一些bug,
当你尝试插入一些<code>printf()</code>之后, bug的行为就会发生变化.
对于这样的bug, etrace还是可以帮助你进行诊断, 因为它是在NEMU中输出的, 不会改变程序的行为.</li>
<li>etrace也不受程序行为的影响: 如果程序包含一些致命的bug导致无法进入异常处理函数,
那就无法在CTE中调用<code>printf()</code>来输出; 在这种情况下, etrace仍然可以正常工作</li>
</ul>
<p>事实上, QEMU和Spike也实现了类似etrace的功能, 如果在上面运行的系统软件发生错误,
开发者也可以通过这些功能快速地进行bug的定位和诊断.</p>
<div class="panel panel-warning"><div class="panel-heading"><h5 class="panel-title" id="实现etrace"><i class="fa fa-edit"></i> 实现etrace</h5></div><div class="panel-body"><p>你已经在NEMU中实现了很多trace工具了, 要实现etrace自然也难不倒你啦.</p></div></div>
<!-- -->
<div class="panel panel-success"><div class="panel-heading"><h5 class="panel-title" id="温馨提示"><i class="fa fa-lightbulb-o"></i> 温馨提示</h5></div><div class="panel-body"><p>PA3阶段1到此结束.</p></div></div>
<footer class="page-footer-ex"> <span class="page-footer-ex-copyright"> By <a href="https://sashimi-yzh.github.io/" target="_blank">Zihao Yu</a>, 采用<a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank">知识共享 署名-非商业性使用-相同方式共享 3.0 中国大陆 许可协议</a>发布 </span>            <span class="page-footer-ex-footer-update"> 此页面修订于:  2023-10-03 23:00:04 </span> </footer>
</section>
</div>
<div class="search-results">
<div class="has-results">
<h1 class="search-results-title"><span class="search-results-count"></span> results matching "<span class="search-query"></span>"</h1>
<ul class="search-results-list"></ul>
</div>
<div class="no-results">
<h1 class="search-results-title">No results matching "<span class="search-query"></span>"</h1>
</div>
</div>
</div>
</div>
</div>
</div>
<a aria-label="Previous page: 最简单的操作系统" class="navigation navigation-prev" href="3.1.html">
<i class="fa fa-angle-left"></i>
</a>
<a aria-label="Next page: 用户程序和系统调用" class="navigation navigation-next" href="3.3.html">
<i class="fa fa-angle-right"></i>
</a>
</div>
<script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"穿越时空的旅程","level":"1.5.2","depth":2,"next":{"title":"用户程序和系统调用","level":"1.5.3","depth":2,"path":"3.3.md","ref":"3.3.md","articles":[]},"previous":{"title":"最简单的操作系统","level":"1.5.1","depth":2,"path":"3.1.md","ref":"3.1.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"3.x.x","theme":"default","variables":{},"plugins":["theme-comscore","intopic-toc","localized-footer","page-footer-ex","callouts"],"pluginsConfig":{"callouts":{"option":{"alert":"info","picto":"fa-edit"},"flag":{"alert":"success","picto":"fa-flag"},"question":{"alert":"info","picto":"fa-question-circle"},"info":{"alert":"info","picto":"fa-info-circle"},"todo":{"alert":"warning","picto":"fa-edit"},"caution":{"alert":"danger","picto":"fa-bullhorn"},"danger":{"alert":"danger","picto":"fa-exclamation"},"showTypeInHeader":false},"intopic-toc":{"isCollapsed":false,"isScrollspyActive":true,"label":"导航","maxDepth":6,"mode":"nested","selector":".markdown-section h2, .markdown-section h3, .markdown-section h4","visible":true},"page-footer-ex":{"copyright":"By [Zihao Yu](https://sashimi-yzh.github.io/), 采用[知识共享 署名-非商业性使用-相同方式共享 3.0 中国大陆 许可协议](http://creativecommons.org/licenses/by-nc-sa/3.0/cn/)发布","markdown":true,"update_format":"YYYY-MM-DD HH:mm:ss","update_label":"此页面修订于: "},"search":{},"localized-footer":{"filename":"FOOTER.md","hline":"true"},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"theme":"white","family":"sans","size":2},"highlight":{},"theme-comscore":{},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles.css","pdf":"styles.css"}},"file":{"path":"3.2.md","mtime":"2023-10-03T15:00:04.849Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2023-12-05T03:26:43.464Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>
{% endblock %}