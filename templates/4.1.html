{% extends 'base.html' %}
{% block head %}
<title>多道程序 · GitBook</title>
<link href="4.2.html" rel="next"/>
<link href="PA4.html" rel="prev"/>
{% endblock %}
{% block body %}
<div class="book">
<div class="book-summary">
<div id="book-search-input" role="search">
<input placeholder="Type to search" type="text"/>
</div>
<nav role="navigation">
<ul class="summary">
<li class="chapter" data-level="1.1" data-path="index.html">
<a href="index.html">
            
                    
                    Introduction
            
                </a>
</li>
<li class="chapter" data-level="1.2" data-path="PA0.html">
<a href="PA0.html">
            
                    
                    PA0 - 世界诞生的前夜: 开发环境配置
            
                </a>
<ul class="articles">
<li class="chapter" data-level="1.2.1" data-path="0.1.html">
<a href="0.1.html">
            
                    
                    Installing GNU/Linux
            
                </a>
</li>
<li class="chapter" data-level="1.2.2" data-path="0.2.html">
<a href="0.2.html">
            
                    
                    First Exploration with GNU/Linux
            
                </a>
</li>
<li class="chapter" data-level="1.2.3" data-path="0.3.html">
<a href="0.3.html">
            
                    
                    Installing Tools
            
                </a>
</li>
<li class="chapter" data-level="1.2.4" data-path="0.4.html">
<a href="0.4.html">
            
                    
                    Configuring vim
            
                </a>
</li>
<li class="chapter" data-level="1.2.5" data-path="0.5.html">
<a href="0.5.html">
            
                    
                    More Exploration
            
                </a>
</li>
<li class="chapter" data-level="1.2.6" data-path="0.6.html">
<a href="0.6.html">
            
                    
                    Getting Source Code for PAs
            
                </a>
</li>
</ul>
</li>
<li class="chapter" data-level="1.3" data-path="PA1.html">
<a href="PA1.html">
            
                    
                    PA1 - 开天辟地的篇章: 最简单的计算机
            
                </a>
<ul class="articles">
<li class="chapter" data-level="1.3.1" data-path="1.1.html">
<a href="1.1.html">
            
                    
                    在开始愉快的PA之旅之前
            
                </a>
</li>
<li class="chapter" data-level="1.3.2" data-path="1.2.html">
<a href="1.2.html">
            
                    
                    开天辟地的篇章
            
                </a>
</li>
<li class="chapter" data-level="1.3.3" data-path="1.3.html">
<a href="1.3.html">
            
                    
                    RTFSC
            
                </a>
</li>
<li class="chapter" data-level="1.3.4" data-path="1.4.html">
<a href="1.4.html">
            
                    
                    基础设施
            
                </a>
</li>
<li class="chapter" data-level="1.3.5" data-path="1.5.html">
<a href="1.5.html">
            
                    
                    表达式求值
            
                </a>
</li>
<li class="chapter" data-level="1.3.6" data-path="1.6.html">
<a href="1.6.html">
            
                    
                    监视点
            
                </a>
</li>
<li class="chapter" data-level="1.3.7" data-path="1.7.html">
<a href="1.7.html">
            
                    
                    如何阅读手册
            
                </a>
</li>
</ul>
</li>
<li class="chapter" data-level="1.4" data-path="PA2.html">
<a href="PA2.html">
            
                    
                    PA2 - 简单复杂的机器: 冯诺依曼计算机系统
            
                </a>
<ul class="articles">
<li class="chapter" data-level="1.4.1" data-path="2.1.html">
<a href="2.1.html">
            
                    
                    不停计算的机器
            
                </a>
</li>
<li class="chapter" data-level="1.4.2" data-path="2.2.html">
<a href="2.2.html">
            
                    
                    RTFSC(2)
            
                </a>
</li>
<li class="chapter" data-level="1.4.3" data-path="2.3.html">
<a href="2.3.html">
            
                    
                    程序, 运行时环境与AM
            
                </a>
</li>
<li class="chapter" data-level="1.4.4" data-path="2.4.html">
<a href="2.4.html">
            
                    
                    基础设施(2)
            
                </a>
</li>
<li class="chapter" data-level="1.4.5" data-path="2.5.html">
<a href="2.5.html">
            
                    
                    输入输出
            
                </a>
</li>
</ul>
</li>
<li class="chapter" data-level="1.5" data-path="PA3.html">
<a href="PA3.html">
            
                    
                    PA3 - 穿越时空的旅程: 批处理系统
            
                </a>
<ul class="articles">
<li class="chapter" data-level="1.5.1" data-path="3.1.html">
<a href="3.1.html">
            
                    
                    最简单的操作系统
            
                </a>
</li>
<li class="chapter" data-level="1.5.2" data-path="3.2.html">
<a href="3.2.html">
            
                    
                    穿越时空的旅程
            
                </a>
</li>
<li class="chapter" data-level="1.5.3" data-path="3.3.html">
<a href="3.3.html">
            
                    
                    用户程序和系统调用
            
                </a>
</li>
<li class="chapter" data-level="1.5.4" data-path="3.4.html">
<a href="3.4.html">
            
                    
                    文件系统
            
                </a>
</li>
<li class="chapter" data-level="1.5.5" data-path="3.5.html">
<a href="3.5.html">
            
                    
                    精彩纷呈的应用程序
            
                </a>
</li>
</ul>
</li>
<li class="chapter" data-level="1.6" data-path="PA4.html">
<a href="PA4.html">
            
                    
                    PA4 - 虚实交错的魔法: 分时多任务
            
                </a>
<ul class="articles">
<li class="chapter active" data-level="1.6.1" data-path="4.1.html">
<a href="4.1.html">
            
                    
                    多道程序
            
                </a>
</li>
<li class="chapter" data-level="1.6.2" data-path="4.2.html">
<a href="4.2.html">
            
                    
                    虚实交错的魔法
            
                </a>
</li>
<li class="chapter" data-level="1.6.3" data-path="4.3.html">
<a href="4.3.html">
            
                    
                    超越容量的界限
            
                </a>
</li>
<li class="chapter" data-level="1.6.4" data-path="4.4.html">
<a href="4.4.html">
            
                    
                    来自外部的声音
            
                </a>
</li>
<li class="chapter" data-level="1.6.5" data-path="4.5.html">
<a href="4.5.html">
            
                    
                    编写不朽的传奇
            
                </a>
</li>
</ul>
</li>
<li class="chapter" data-level="1.7" data-path="blank.html">
<a href="blank.html">
            
                    
                    杂项
            
                </a>
<ul class="articles">
<li class="chapter" data-level="1.7.1" data-path="FAQ.html">
<a href="FAQ.html">
            
                    
                    常见问题(FAQ)
            
                </a>
</li>
<li class="chapter" data-level="1.7.2" data-path="why.html">
<a href="why.html">
            
                    
                    为什么要学习计算机系统基础
            
                </a>
</li>
<li class="chapter" data-level="1.7.3" data-path="linux.html">
<a href="linux.html">
            
                    
                    Linux入门教程
            
                </a>
</li>
<li class="chapter" data-level="1.7.4" data-path="man.html">
<a href="man.html">
            
                    
                    man入门教程
            
                </a>
</li>
<li class="chapter" data-level="1.7.5" data-path="git.html">
<a href="git.html">
            
                    
                    git入门教程
            
                </a>
</li>
<li class="chapter" data-level="1.7.6" data-path="nemu-isa-api.html">
<a href="nemu-isa-api.html">
            
                    
                    NEMU ISA相关API说明文档
            
                </a>
</li>
<li class="chapter" data-level="1.7.7" data-path="changelog.html">
<a href="changelog.html">
            
                    
                    更新日志
            
                </a>
</li>
<li class="chapter" data-level="1.7.8" data-path="i386-intro.html">
<a href="i386-intro.html">
            
                    
                    i386手册指令集阅读指南
            
                </a>
</li>
</ul>
</li>
<li class="divider"></li>
<li>
<a class="gitbook-link" href="https://www.gitbook.com" target="blank">
            Published with GitBook
        </a>
</li>
</ul>
</nav>
</div>
<div class="book-body">
<div class="body-inner">
<div class="book-header" role="navigation">
<!-- Title -->
<h1>
<i class="fa fa-circle-o-notch fa-spin"></i>
<a href=".">多道程序</a>
</h1>
</div>
<div class="page-wrapper" role="main" tabindex="-1">
<div class="page-inner">
<div id="book-search-results">
<div class="search-noresults">
<section class="normal markdown-section">
<div class="panel panel-danger"><div class="panel-heading"><h5 class="panel-title" id="甩锅声明"><i class="fa fa-bullhorn"></i> 甩锅声明</h5></div><div class="panel-body"><p>从PA4开始, 讲义中就不再提供滴水不漏的代码指导了,
部分关键的代码细节需要你自己去思考和尝试(我们故意省略的).
我们会在讲义中将技术的原理阐述清楚,
你需要首先理解这些原理, 然后根据理解来阅读并编写相应的代码.</p><p>一句话总结, 与其抱怨讲义写得不清楚, 还不如自己多多思考.
现在都到PA4了, 为了让成绩符合正态分布, 拿高分总需要多付出点努力吧.
如果你之前都是想办法投机取巧而不去深入理解系统如何工作, 现在应该已经没戏了.</p></div></div>
<h2 id="多道程序">多道程序</h2>
<p>通过Nanos-lite的支撑, 我们已经在NEMU中成功运行了一个批处理系统, 并把仙剑奇侠传跑起来了!
这说明我们亲自构建的NEMU这个看似简单的机器, 同样能支撑真实程序的运行, 丝毫不逊色于真实的机器!
不过, 这个批处理系统目前还是只能同时运行一个程序,
只有当一个程序结束执行之后, 才会开始执行下一个程序.</p>
<p>这也正是批处理系统的一个缺陷:
如果当前程序正在等待输入输出, 那么整个系统都会因此而停顿.
在真实的计算机中, 和CPU的性能相比, 输入输出是非常缓慢的:
以磁盘为例, 磁盘进行一次读写需要花费大约5毫秒的时间,
但对于一个2GHz的CPU来说, 它需要花费10,000,000个周期来等待磁盘操作的完成.
但事实上, 与其让系统陷入无意义的等待, 还不如用这些时间来进行一些有意义的工作.
一个简单的想法就是, 在系统一开始的时候加载多个程序, 然后运行第一个;
当第一个程序需要等待输入输出的时候, 就切换到第二个程序来运行;
当第二个程序也需要等待的时候, 就继续切换到下一个程序来运行, 如此类推.</p>
<p>这就是<a href="https://en.wikipedia.org/wiki/Computer_multitasking#Multiprogramming" target="_blank">多道程序(multiprogramming)</a>系统的基本思想.
多道程序的想法听上去很简单, 但它也是一种多任务系统,
这是因为它已经包含了多任务系统的基本要素.
换句话说, 要实现一个多道程序操作系统,
我们只需要实现以下两点就可以了:</p>
<ul>
<li>在内存中可以同时存在多个进程</li>
<li>在满足某些条件的情况下, 可以让执行流在这些进程之间切换</li>
</ul>
<div class="panel panel-success"><div class="panel-heading"><h5 class="panel-title" id="术语变更"><i class="fa fa-lightbulb-o"></i> 术语变更</h5></div><div class="panel-body"><p>既然是多任务系统, 系统中就运行的程序就不止一个了.
现在我们就可以直接使用"进程"的概念了.</p></div></div>
<p>要实现第一点并不难, 我们只要让loader把不同的进程加载到不同的内存位置就可以了,
加载进程的过程本质上就是一些内存拷贝的操作, 因此并没有什么困难的地方.</p>
<div class="panel panel-info"><div class="panel-heading"><h5 class="panel-title" id="其实我在骗你"><i class="fa fa-comment-o"></i> 其实我在骗你!</h5></div><div class="panel-body"><p>对我们目前实现的计算机系统来说, "把不同的进程加载到不同的内存位置"其实是一件很麻烦的事情,
你能想明白为什么吗? 如果想不明白也没关系, 我们会在下一阶段详细讨论这个问题.</p></div></div>
<p>为了简单起见, 我们可以在操作系统中直接定义一些测试函数来作为程序,
因为程序本质上就是一些有意义的指令序列, 目前我们不必在意这些指令序列到底从何而来.
不过, 一个需要注意的地方是栈, 我们需要为每个进程分配各自的栈空间.</p>
<div class="panel panel-info"><div class="panel-heading"><h5 class="panel-title" id="为什么需要使用不同的栈空间"><i class="fa fa-question-circle"></i> 为什么需要使用不同的栈空间?</h5></div><div class="panel-body"><p>如果不同的进程共享同一个栈空间, 会发生什么呢?</p></div></div>
<p>反而需要深思熟虑的是第二点: 表面上看, "怎么让执行流在进程之间切换"并不是一件直观的事情.</p>
<h2 id="上下文切换">上下文切换</h2>
<p>在PA3中, 我们已经提到了操作系统和用户进程之间的执行流切换,
并介绍了"上下文"的概念: 上下文的本质就是进程的状态.
换句话说, 我们现在需要考虑的是, 如何在多个用户进程之间进行上下文切换.</p>
<p>为了帮助大家理解这个问题, 我们在<code>am-kernels</code>中为大家准备了一个约30行的操作系统<code>yield-os</code>,
它创建了两个执行流, 在CTE的支撑下交替输出<code>A</code>和<code>B</code>.
你可以在<code>native</code>上运行<code>yield-os</code>来查看它的行为.</p>
<div class="panel panel-danger"><div class="panel-heading"><h5 class="panel-title" id="更新am-kernels"><i class="fa fa-exclamation"></i> 更新am-kernels</h5></div><div class="panel-body"><p>我们在2023年10月3日15:35:00在<code>am-kernels</code>中添加了<code>yield-os</code>的代码.
如果你在此时间前获取<code>am-kernels</code>的代码, 请通过以下命令获取更新后的代码:</p><pre><code class="lang-bash"><span class="hljs-built_in">cd</span> am-kernels
git pull origin master
</code></pre></div></div>
<h3 id="基本原理">基本原理</h3>
<p>事实上, 有了CTE, 我们就有一种很巧妙的方式来实现上下文切换了.
具体地, 假设进程A运行的过程中触发了系统调用, 通过自陷指令陷入到内核.
根据<code>__am_asm_trap()</code>的代码, A的上下文结构(<code>Context</code>)将会被保存到A的栈上.
在PA3中, 系统调用处理完毕之后, <code>__am_asm_trap()</code>会根据栈上保存的上下文结构来恢复A的上下文.
神奇的地方来了, 如果我们先不着急恢复A的上下文,
而是先将栈顶指针切换到另一个进程B的栈上, 那会发生什么呢?
由于B的栈上存放了之前B保存的上下文结构, 接下来的操作就会根据这一结构来恢复B的上下文.
从<code>__am_asm_trap()</code>返回之后, 我们已经在运行进程B了!</p>
<p><img alt="context-switch" src="images/Context-switch.png"/></p>
<p>那进程A到哪里去了呢? 别担心, 它只是被暂时"挂起"了而已.
在被挂起之前, 它已经把上下文结构保存到自己的栈上了,
如果将来的某一时刻栈顶指针被切换到A的栈上,
代码将会根据栈上的上下文结构来恢复A的上下文, A将得以唤醒并执行.
所以, 上下文切换其实就是不同进程之间的栈切换!</p>
<h3 id="进程控制块">进程控制块</h3>
<p>但是, 我们要如何找到别的进程的上下文结构呢?
注意到上下文结构是保存在栈上的, 但栈空间那么大,
受到函数调用形成的栈帧的影响, 每次保存上下文结构的位置并不是固定的.
自然地, 我们需要一个<code>cp</code>指针(context pointer)来记录上下文结构的位置,
当想要找到其它进程的上下文结构的时候, 只要寻找这个进程相关的<code>cp</code>指针即可.</p>
<p>事实上, 有不少信息都是进程相关的,
除了刚才提到的上下文指针<code>cp</code>之外, 上文提到的栈空间也是如此.
为了方便对这些进程相关的信息进行管理,
操作系统使用一种叫进程控制块(PCB, process control block)的数据结构, 为每一个进程维护一个PCB.
<code>yield-os</code>的代码中已经定义了我们所需要使用的PCB结构:</p>
<pre><code class="lang-c"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">union</span> {
  <span class="hljs-keyword">uint8_t</span> <span class="hljs-built_in">stack</span>[STACK_SIZE];
  <span class="hljs-keyword">struct</span> {
    Context *cp;
  };
} PCB;
</code></pre>
<p>代码使用一个联合体来把其它信息放置在进程堆栈的底部.
代码为每一个进程分配了一个32KB的堆栈, 已经足够使用了, 不会出现栈溢出导致UB.
在进行上下文切换的时候, 只需要把PCB中的<code>cp</code>指针返回给CTE的<code>__am_irq_handle()</code>函数即可,
剩余部分的代码会根据上下文结构恢复上下文.
我们只要稍稍借助数学归纳法, 就可以让我们相信这个过程对于正在运行的进程来说总是正确的.</p>
<p>那么, 对于刚刚加载完的进程, 我们要怎么切换到它来让它运行起来呢?</p>
<h3 id="内核线程">内核线程</h3>
<h4 id="创建内核线程上下文">创建内核线程上下文</h4>
<p>答案很简单, 我们只需要在进程的栈上人工创建一个上下文结构,
使得将来切换的时候可以根据这个结构来正确地恢复上下文即可.</p>
<p>上文提到, 我们先把操作系统中直接定义的一些测试函数作为程序.
<code>yield-os</code>提供了一个测试函数<code>f()</code>,
我们接下来的任务就是为它创建一个上下文, 然后切换到它来执行.
这样的执行流有一个专门的名称, 叫"内核线程"(kernel thread).</p>
<div class="panel panel-info"><div class="panel-heading"><h5 class="panel-title" id="为什么不叫内核进程"><i class="fa fa-comment-o"></i> 为什么不叫"内核进程"?</h5></div><div class="panel-body"><p>这个问题其实等价于"进程和线程有什么区别", 是个不错的问题.
而且这还属于考研八股的内容呢, 于是你肯定可以通过STFW找到很多五花八门的答案,
比如"线程更加轻量级", "线程没有独立的资源"等等.</p><p>如果要进一步解释"什么是轻量级", "独立的资源是什么意思", 在PA中可能比较困难.
不过在PA中也不必深究这个问题, 目前你只需要把它们都看成执行流就可以了,
更重要的是, 这两者你都将会实现, 在代码中亲自去感受它们的区别不是一个更好的选择吗?
另外, 带着这个问题去修读下学期的操作系统课也不错.</p></div></div>
<p>创建内核线程的上下文是通过CTE提供的<code>kcontext()</code>函数
(在<code>abstract-machine/am/src/$ISA/nemu/cte.c</code>中定义)来实现的,
其中的"k"代表内核. <code>kcontext()</code>的原型是</p>
<pre><code class="lang-c">Context* kcontext(Area kstack, void (*entry)(void *), void *arg);
</code></pre>
<p>其中<code>kstack</code>是栈的范围, <code>entry</code>是内核线程的入口, <code>arg</code>则是内核线程的参数.
此外, <code>kcontext()</code>要求内核线程不能从<code>entry</code>返回, 否则其行为是未定义的.
你需要在<code>kstack</code>的底部创建一个以<code>entry</code>为入口的上下文结构(目前你可以先忽略<code>arg</code>参数),
然后返回这一结构的指针.</p>
<p><code>yield-os</code>会调用<code>kcontext()</code>来创建上下文, 并把返回的指针记录到PCB的<code>cp</code>中:</p>
<pre><code>|               |
+---------------+ &lt;---- kstack.end
|               |
|    context    |
|               |
+---------------+ &lt;--+
|               |    |
|               |    |
|               |    |
|               |    |
+---------------+    |
|       cp      | ---+
+---------------+ &lt;---- kstack.start
|               |
</code></pre><h4 id="线程进程调度">线程/进程调度</h4>
<p>上下文的创建和切换是CTE的工作, 而具体切换到哪个上下文,
则是由操作系统来决定的, 这项任务叫做进程调度.
进程调度是由<code>schedule()</code>函数来完成的, 它用于返回将要调度的进程上下文.
因此, 我们需要一种方式来记录当前正在运行哪一个进程,
这样我们才能在<code>schedule()</code>中返回另一个进程的上下文, 以实现多任务的效果.
这一工作是通过<code>current</code>指针来实现的, 它用于指向当前运行进程的PCB.
这样, 我们就可以在<code>schedule()</code>中通过<code>current</code>来决定接下来要调度哪一个进程了.
不过在调度之前, 我们还需要把当前进程的上下文指针保存在PCB当中:</p>
<pre><code class="lang-c"><span class="hljs-comment">// save the context pointer</span>
current-&gt;cp = prev;

<span class="hljs-comment">// switch between pcb[0] and pcb[1]</span>
current = (current == &amp;pcb[<span class="hljs-number">0</span>] ? &amp;pcb[<span class="hljs-number">1</span>] : &amp;pcb[<span class="hljs-number">0</span>]);

<span class="hljs-comment">// then return the new context</span>
<span class="hljs-keyword">return</span> current-&gt;cp;
</code></pre>
<p>目前我们让<code>schedule()</code>总是切换到另一个进程.
注意所选进程的上下文是通过<code>kcontext()</code>创建的,
在<code>schedule()</code>中才决定要切换到它, 然后在CTE的<code>__am_asm_trap()</code>中才真正地恢复这一上下文.</p>
<div class="panel panel-info"><div class="panel-heading"><h5 class="panel-title" id="机制和策略解耦"><i class="fa fa-comment-o"></i> 机制和策略解耦</h5></div><div class="panel-body"><p>这其实体现了系统设计中的一种重要原则: 机制和策略解耦.
机制解决的是"能不能做"的问题, 而策略解决的则是"怎么做好"的问题.
显然, 策略需要机制的支撑, 机制需要策略来发挥最大的效果.</p><p>解耦的好处就很明显了: 代码重用率高, 而且容易理解.
在Project-N中, 这一解耦几乎做到了极致: 机制和策略被分离到两个子项目中.
比如, "上下文切换"这一机制是在AM的CTE中实现的, 它让系统可以做到"执行流的切换"这件事;
而具体要切换到哪一个执行流, 则是在操作系统中实现的.</p><p>AM的另外一个好处是将底层硬件的行为抽象成系统级机制,
AM上的应用(包括OS)只需要调用这些系统级机制, 并实现相应的策略即可.
当然目前<code>schedule()</code>中的策略非常简单, 下学期的操作系统实验,
甚至是现实中更复杂的进程调度策略, 都可以在AM提供的同一个机制之上实现.</p></div></div>
<!-- -->
<div class="panel panel-warning"><div class="panel-heading"><h5 class="panel-title" id="实现上下文切换"><i class="fa fa-edit"></i> 实现上下文切换</h5></div><div class="panel-body"><p>根据讲义的上述内容, 实现以下功能:</p><ul>
<li>CTE的<code>kcontext()</code>函数</li>
<li>修改CTE中<code>__am_asm_trap()</code>的实现, 使得从<code>__am_irq_handle()</code>返回后,
先将栈顶指针切换到新进程的上下文结构, 然后才恢复上下文, 从而完成上下文切换的本质操作</li>
</ul><p>正确实现后, 你将看到<code>yield-os</code>不断输出<code>?</code>, 这是因为我们还没有为<code>kcontext()</code>实现参数功能,
不过这些输出的<code>?</code>至少说明了CTE目前可以正确地从<code>yield-os</code>的<code>main()</code>函数切换到其中一个内核线程.</p></div></div>
<!-- -->
<div class="panel panel-success"><div class="panel-heading"><h5 class="panel-title" id="关于kcontext的提示"><i class="fa fa-lightbulb-o"></i> 关于kcontext()的提示</h5></div><div class="panel-body"><p>我们希望代码将来从<code>__am_asm_trap()</code>返回之后, 就会开始执行<code>f()</code>.
换句话说, 我们需要在<code>kcontext()</code>中构造一个上下文, 它指示了一个状态,
从这个状态开始, 可以正确地开始执行<code>f()</code>.
所以你需要思考的是, 为了可以正确地开始执行<code>f()</code>,
这个状态究竟需要满足什么样的条件?</p><p>至于"先将栈顶指针切换到新进程的上下文结构", 很自然的问题就是,
新进程的上下文结构在哪里? 怎么找到它? 又应该怎么样把栈顶指针切换过去?
如果你发现代码跑飞了, 不要忘记, 程序是个状态机.</p></div></div>
<!-- -->
<div class="panel panel-success"><div class="panel-heading"><h5 class="panel-title" id="配合difftest"><i class="fa fa-lightbulb-o"></i> 配合DiffTest</h5></div><div class="panel-body"><p>为了保证DiffTest的正确运行, 根据你选择的ISA, 你还需要进行一些额外的设置:</p><ul>
<li>x86: 把上下文结构中的<code>cs</code>设置为<code>8</code>.</li>
<li>riscv32: 把上下文结构中的<code>mstatus</code>设置为<code>0x1800</code>.</li>
<li>riscv64, 把上下文结构中的<code>mstatus</code>设置为<code>0xa00001800</code>.</li>
</ul></div></div>
<h4 id="内核线程的参数">内核线程的参数</h4>
<p>为了让<code>yield-os</code>的内核线程可以正确输出字符, 我们需要通过<code>kcontext()</code>给<code>f()</code>传参.
于是我们需要继续思考, <code>f()</code>将会如何读出它的参数?
噢, 这不就是调用约定的内容吗? 你已经非常熟悉了.
我们只需要让<code>kcontext()</code>按照调用约定将<code>arg</code>放置在正确的位置,
将来<code>f()</code>执行的时候就可以获取正确的参数了.</p>
<div class="panel panel-info"><div class="panel-heading"><h5 class="panel-title" id="mips32和riscv32的调用约定"><i class="fa fa-question-circle"></i> mips32和riscv32的调用约定</h5></div><div class="panel-body"><p>我们没有给出mips32和riscv32的调用约定, 你需要查阅相应的ABI手册.
当然, 你也可以自己动手实践来总结传参的规则.</p></div></div>
<!-- -->
<div class="panel panel-warning"><div class="panel-heading"><h5 class="panel-title" id="实现上下文切换2"><i class="fa fa-edit"></i> 实现上下文切换(2)</h5></div><div class="panel-body"><p>根据讲义的上述内容, 修改CTE的<code>kcontext()</code>函数, 使其支持参数<code>arg</code>的传递.</p><p>因为<code>f()</code>中每次输出完信息都会调用<code>yield()</code>, 因此只要我们正确实现内核线程的参数传递,
就可以观察到<code>yield-os</code>在两个内核线程之间来回切换的现象.</p></div></div>
<p>在真实的操作系统中, 内核中的很多后台任务, 守护服务和驱动程序都是以内核线程的形式存在的.
如果你执行<code>ps aux</code>, 你就会看到系统中有很多COMMAND中带有中括号的内核线程(例如<code>[kthreadd]</code>).
而创建和执行它们的原理, 也是和上面的实验内容非常相似(当然具体实现肯定会有所不同).</p>
<div class="panel panel-info"><div class="panel-heading"><h5 class="panel-title" id="保持kcontext的特性"><i class="fa fa-edit"></i> 保持kcontext()的特性</h5></div><div class="panel-body"><p>AM在定义<code>kcontext()</code>的行为时, 还要求<code>kcontext()</code>只能在栈上放置一个上下文结构,
而不能放置更多的内容. 这样的要求有两点好处:</p><ul>
<li><code>kcontext()</code>对栈的写入只有一个上下文结构的内容, 而不会产生其它的副作用</li>
<li>OS可以预测调用<code>kcontext()</code>之后的返回值, 并且利用这一确定的特性进行一些检查或者简化某些实现</li>
</ul><p>我们知道x86是通过栈来传递参数的, 如果<code>kcontext()</code>需要支持<code>arg</code>的传递,
它就需要往栈上放置更多的内容, 这样就违反了上述确定性了.
但在PA中, 这并不会导致致命的问题, 因此我们并不要求你的<code>kcontext()</code>实现严格遵守这一确定性.
但你还是可以思考如何在遵守确定性的情况下实现参数的传递.</p><p>一个解决方案是通过引入一个辅助函数来将真正的参数传递从<code>kcontext()</code>推迟到内核线程的运行时刻.
具体地, 我们可以在<code>kcontext()</code>中先把内核线程的入口设置为辅助函数,
并把参数设置到某个可用的寄存器中. 这样以后, 内核线程就会从辅助函数开始执行,
此时让辅助函数来把之前设置的参数从寄存器中放置到栈上, 再调用真正的线程入口函数(<code>f()</code>).
这一方案和Linux中加载用户程序还是有一些相似之处的:
用户程序在运行的时候也并不是直接把<code>main()</code>函数作为入口,
而是先从CRT定义的<code>_start()</code>开始运行, 进行包括设置参数在内的一系列初始化操作,
最后才调用<code>main()</code>函数.</p><p>如果你选择的ISA是x86, 你可以尝试在CTE中实现上述辅助函数.
考虑到要直接操作寄存器和栈, 这个辅助函数还是通过汇编代码来编写比较合适.
不过由于这个辅助函数的功能比较简单, 你只需要编写几条指令就可以实现它了.</p></div></div>
<h2 id="os中的上下文切换">OS中的上下文切换</h2>
<p><code>yield-os</code>是一个很小的OS, 除了上下文切换之外, 不具备其他功能,
但它可以帮助我们专注于理解上下文切换的核心细节.
理解这些细节后, 我们也可以很快将这些原理迁移到更大的OS中.</p>
<h3 id="rt-thread选做">RT-Thread(选做)</h3>
<p>RT-Thread是一个流行的商业级嵌入式实时OS, 具备完善的OS功能模块,
可以适配各种不同的开发板, 并支撑各种应用程序的运行.</p>
<p>RT-Thread中有两个抽象层, 一个是BSP(Board Support Package), 另一个是libcpu.
BSP为各种型号的板卡定义了一套公共的API, 并基于这套API实现RT-Thread内核;
而对于一款板卡, 只需要实现相应的API, 就可以将RT-Thread内核运行在这款板卡上.
libcpu则是为各种CPU架构定义了一套公共的API, RT-Thread内核也会调用其中的某些API.
这一思想和AM非常类似. 当然, BSP也不仅仅是针对真实的板卡, 也可以对应QEMU等模拟器,
毕竟RT-Thread内核无需关心底层是否是一个真实的板卡.</p>
<p>我们把RT-Thread移植到AM上, 编译运行这个RT-Thread的步骤如下:</p>
<ol>
<li>以通过以下命令获取移植之后的RT-Thread:<pre><code class="lang-bash"><span class="hljs-built_in">cd</span> ~/Templates  <span class="hljs-comment"># 在另一个目录下克隆代码, 因为RT-Thread的代码无需打包提交</span>
git <span class="hljs-built_in">clone</span> git@github.com:NJU-ProjectN/rt-thread-am.git
</code></pre>
</li>
<li>为了编译代码, 你还需要安装项目构建工具<code>scons</code>:<pre><code class="lang-bash">apt-get install scons
</code></pre>
</li>
<li>在<code>rt-thread-am/bsp/abstract-machine/</code>目录下执行<code>make init</code>, 进行一些编译前的准备工作,
此命令只需执行一次即可, 后续编译运行前无需再次执行</li>
<li><p>在相同目录下通过<code>make ARCH=native</code>等方式编译或运行RT-Thread, 默认的运行输出如下:</p>
<pre><code>heap: [0x01000000 - 0x09000000]

 \ | /
- RT -     Thread Operating System
 / | \     5.0.1 build Oct  2 2023 20:51:10
 2006 - 2022 Copyright by RT-Thread team
Assertion fail at rt-thread-am/bsp/abstract-machine/src/context.c:29
</code></pre><p>运行后触发了assertion, 这是因为代码中有部分功能需要大家实现.</p>
</li>
</ol>
<p>我们去掉了原项目中所有BSP和libcpu, 然后添加了一个特殊的BSP,
并用AM的API来实现BSP的API, 具体见<code>rt-thread-am/bsp/abstract-machine/</code>目录下的代码.
用到的AM API如下:</p>
<ul>
<li>用TRM的heap实现RT-Thread中的堆</li>
<li>用TRM的<code>putch()</code>实现RT-Thread中的串口输出功能</li>
<li>暂不使用IOE</li>
<li>用CTE的<code>iset()</code>实现RT-Thread中开/关中断功能</li>
<li>通过CTE实现RT-Thread中上下文的创建和切换功能.
此部分代码并未实现, 我们将它作为选做作业.</li>
</ul>
<p>对于上下文的创建, 你需要实现<code>rt-thread-am/bsp/abstract-machine/src/context.c</code>中的<code>rt_hw_stack_init()</code>函数:</p>
<pre><code class="lang-c"><span class="hljs-keyword">rt_uint8_t</span> *rt_hw_stack_init(<span class="hljs-keyword">void</span> *tentry, <span class="hljs-keyword">void</span> *parameter, <span class="hljs-keyword">rt_uint8_t</span> *stack_addr, <span class="hljs-keyword">void</span> *texit);
</code></pre>
<p>它的功能是以<code>stack_addr</code>为栈底创建一个入口为<code>tentry</code>, 参数为<code>parameter</code>的上下文,
并返回这个上下文结构的指针. 此外, 若上下文对应的内核线程从<code>tentry</code>返回, 则调用<code>texit</code>,
RT-Thread会保证代码不会从<code>texit</code>中返回.
需要注意:</p>
<ol>
<li>传入的<code>stack_addr</code>可能没有任何对齐限制, 最好将它对齐到<code>sizeof(uintptr_t)</code>再使用.</li>
<li>CTE的<code>kcontext()</code>要求不能从入口返回, 因此需要一种新的方式来支持<code>texit</code>的功能.
一种方式是构造一个包裹函数, 让包裹函数来调用<code>tentry</code>, 并在<code>tentry</code>返回后调用<code>texit</code>,
然后将这个包裹函数作为<code>kcontext()</code>的真正入口, 不过这还要求我们将<code>tentry</code>,
<code>parameter</code>和<code>texit</code>这三个参数传给包裹函数, 应该如何解决这个传参问题呢?</li>
</ol>
<p>对于上下文的切换, 你需要实现<code>rt-thread-am/bsp/abstract-machine/src/context.c</code>中的<code>rt_hw_context_switch_to()</code>函数和<code>rt_hw_context_switch()</code>函数:</p>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rt_hw_context_switch_to</span><span class="hljs-params">(rt_ubase_t to)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rt_hw_context_switch</span><span class="hljs-params">(rt_ubase_t from, rt_ubase_t to)</span></span>;
</code></pre>
<p>其中<code>rt_ubase_t</code>类型其实是<code>unsigned long</code>, <code>to</code>和<code>from</code>都是指向上下文指针变量的指针(二级指针).
<code>rt_hw_context_switch_to()</code>用于切换到<code>to</code>指向的上下文指针变量所指向的上下文,
而<code>rt_hw_context_switch()</code>还需要额外将当前上下文的指针写入<code>from</code>指向的上下文指针变量中.
为了进行切换, 我们可以通过<code>yield()</code>触发一次自陷,
在事件处理回调函数<code>ev_handler()</code>中识别出<code>EVENT_YIELD</code>事件后, 再处理<code>to</code>和<code>from</code>.
同样地, 我们需要思考如何将<code>to</code>和<code>from</code>这两个参数传给<code>ev_handler()</code>.
在<code>rt-thread-am/bsp/abstract-machine/src/context.c</code>中还有一个<code>rt_hw_context_switch_interrupt()</code>函数,
不过目前RT-Thread的运行过程不会调用它, 因此目前可以忽略它.</p>
<p>根据分析, 上面两个功能的实现都需要处理一些特殊的参数传递问题.
对于上下文的切换, 以<code>rt_hw_context_switch()</code>为例,
我们需要在<code>rt_hw_context_switch()</code>中调用<code>yield()</code>, 然后在<code>ev_handler()</code>中获得<code>from</code>和<code>to</code>.
<code>rt_hw_context_switch()</code>和<code>ev_handler()</code>是两个不同的函数, 但由于CTE机制的存在,
使得<code>rt_hw_context_switch()</code>不能直接调用<code>ev_handler()</code>.
因此, 一种直接的方式就是借助全局变量来传递信息.</p>
<div class="panel panel-danger"><div class="panel-heading"><h5 class="panel-title" id="危险的全局变量"><i class="fa fa-exclamation"></i> 危险的全局变量</h5></div><div class="panel-body"><p>全局变量在整个系统中只有一个副本, 如果整个系统中只有一个线程, 这通常是安全的.
我们在C语言课上编写的程序都属于这种情况, 所以使用全局变量并不会造成明显的正确性问题.
但如果系统中存在多个线程, 并且它们使用同一个全局变量的时间段有重叠, 就可能会造成问题.</p><p>不过目前我们的硬件既未实现中断, 也不支持多处理器,
从编程模型来看和C语言课差不多, 因此使用全局变量解决这个问题还是可以的.</p></div></div>
<!-- -->
<div class="panel panel-info"><div class="panel-heading"><h5 class="panel-title" id="危险的全局变量2"><i class="fa fa-question-circle"></i> 危险的全局变量(2)</h5></div><div class="panel-body"><p>如果使用全局变量来传递信息, 考虑以下场景, 可能会出现什么问题?</p><ul>
<li>在多处理器系统中, 两个处理器同时调用<code>rt_hw_context_switch()</code></li>
<li>一个线程调用<code>rt_hw_context_switch()</code>后写入了全局变量, 但马上到来了时钟中断,
使得系统切换到另一个线程, 但这个线程也调用了<code>rt_hw_context_switch()</code></li>
</ul></div></div>
<p>但对于上下文的创建, 问题就更复杂了: 调用<code>rt_hw_stack_init()</code>和执行包裹函数的两个线程并不相同.</p>
<div class="panel panel-info"><div class="panel-heading"><h5 class="panel-title" id="危险的全局变量3"><i class="fa fa-question-circle"></i> 危险的全局变量(3)</h5></div><div class="panel-body"><p>如果使用全局变量来传递信息, 而代码连续调用了两次<code>rt_hw_stack_init()</code>, 会造成什么问题?</p></div></div>
<p>因此, 我们需要寻找另一种解决方案.
回过头来看, 全局变量造成问题的原因是它会被多个线程共享,
为了得到正确的解决方案, 我们应该反其道而行之: 使用一种不会被多个线程共享的存储空间.
嘿嘿, 其实前文已经提到过它了, 那就是栈!
我们只需要让<code>rt_hw_stack_init()</code>将包裹函数的三个参数放在上下文的栈中,
将来包裹函数执行的时候就可以从栈中取出这三个参数, 而且系统中的其他线程都不能访问它们.</p>
<p>最后还需要考虑参数数量的问题, <code>kcontext()</code>要求入口函数只能接受一个类型为<code>void *</code>的参数.
不过我们可以自行约定用何种类型来解析这个参数(整数, 字符, 字符串, 指针等皆可),
于是这就成了一个C语言的编程题了.</p>
<div class="panel panel-info"><div class="panel-heading"><h5 class="panel-title" id="通过cte实现rt-thread的上下文创建和切换"><i class="fa fa-edit"></i> 通过CTE实现RT-Thread的上下文创建和切换</h5></div><div class="panel-body"><p>根据上述内容实现相关代码.
对于<code>rt_hw_stack_init()</code>的实现, 我们已经给出了解决问题的正确方向,
但我们并没有指出所有实现相关的细节问题, 剩下的就交给你来分析解决吧,
这也是考察你是否已经了解这个过程中的每一处细节.</p><p>实现后, 尝试在NEMU中运行RT-Thread. 我们已经在移植后的RT-Thread中内置了一些Shell命令,
如果你的代码实现正确, 将能看到RT-Thread启动后依次执行这些命令, 最后输出命令提示符<code>msh &gt;</code>:</p><pre><code>heap: [0x01000000 - 0x09000000]

 \ | /
- RT -     Thread Operating System
 / | \     5.0.1 build Oct  2 2023 20:51:10
 2006 - 2022 Copyright by RT-Thread team
[I/utest] utest is initialize success.
[I/utest] total utest testcase num: (0)
Hello RISC-V!
msh /&gt;help
RT-Thread shell commands:
date       - get date and time or set (local timezone) [year month day hour min sec]

......

msh /&gt;utest_list
[I/utest] Commands list :
msh /&gt;
</code></pre><p>由于NEMU目前还不支持通过串口进行交互, 因此我们无法将终端上的输入传送到RT-Thread,
所有内置命令运行结束后, RT-Thread将进入空闲状态, 此时退出NEMU即可.</p></div></div>
<!-- -->
<div class="panel panel-success"><div class="panel-heading"><h5 class="panel-title" id="在native上进行上下文切换"><i class="fa fa-lightbulb-o"></i> 在native上进行上下文切换</h5></div><div class="panel-body"><p>由于native的AM在创建上下文的时候默认会打开中断, 为了成功运行native创建的内核线程,
你还需要在事件处理回调函数中识别出时钟中断事件. 我们会在PA4的最后介绍时钟中断相关的内容,
目前识别出时钟中断事件之后什么都不用做, 直接返回相应的上下文结构即可.</p></div></div>
<!-- -->
<div class="panel panel-info"><div class="panel-heading"><h5 class="panel-title" id="危险的全局变量4"><i class="fa fa-edit"></i> 危险的全局变量(4)</h5></div><div class="panel-body"><p>能否不使用全局变量来实现上下文的切换呢?</p><p>同样地, 我们需要寻找一种不会被多个线程共享的存储空间.
不过对于调用<code>rt_hw_context_switch()</code>的线程来说, 它的栈正在被使用,
往其中写入数据可能会被覆盖, 甚至可能会覆盖已有数据, 使当前线程崩溃.
<code>to</code>的栈虽然当前不使用, 也不会被其他线程共享,
但需要考虑如何让<code>ev_handler()</code>访问到<code>to</code>的栈, 这又回到了我们一开始想要解决的问题.</p><p>除了栈之外, 还有没有其他不会被多个线程共享的存储空间呢?
嘿嘿, 其实前文也已经提到过它了, 那就是PCB!
因为每个线程对应一个PCB, 而一个线程不会被同时调度多次,
所以通过PCB来传递信息也是一个可行的方案.
要获取当前线程的PCB, 自然是用<code>current</code>指针了.</p><p>在RT-Thread中, 可以通过调用<code>rt_thread_self()</code>返回当前线程的PCB.
阅读RT-Thread中PCB结构体的定义, 我们发现其中有一个成员<code>user_data</code>, 它用于存放线程的私有数据,
这意味着RT-Thread中调度相关的代码必定不会使用这个成员, 因此它很适合我们用来传递信息.
不过为了避免覆盖<code>user_data</code>中的已有数据, 我们可以先把它保存在一个临时变量中,
在下次切换回当前线程并从<code>rt_hw_context_switch()</code>返回之前再恢复它.
至于这个临时变量, 当然是使用局部变量了, 毕竟局部变量是在栈上分配的, 完美!</p></div></div>
<p>不过, 目前AM提供的功能不如其他BSP那么丰富,
RT-Thread中一些更复杂的功能还需要底层硬件提供支持, 如网络, 存储等.
因此, 目前我们只能在AM上运行RT-Thread的一个子集, 但这对我们测试和展示来说也足够了.</p>
<h3 id="nanos-lite">Nanos-lite</h3>
<p>RT-Thread固然是一个完整的OS, 但其内核代码也有约16000行代码,
相比之下Nanos-lite的代码量不到1000行, 更适合大家学习核心原理.
因此, 后续的实验还是会基于Nanos-lite进行.</p>
<p>Nanos-lite上下文切换需要用到的函数和数据结构和<code>yield-os</code>非常类似,
只不过由于Nanos-lite的代码规模更大, 它们分散在不同的文件中, 你需要RTFSC找到它们.
此外, Nanos-lite的框架代码已经定义了PCB结构体,
其中还包含其他目前暂不使用的成员, 我们会在将来介绍它们.</p>
<div class="panel panel-warning"><div class="panel-heading"><h5 class="panel-title" id="在nanos-lite中实现上下文切换"><i class="fa fa-edit"></i> 在Nanos-lite中实现上下文切换</h5></div><div class="panel-body"><p>实现以下功能:</p><ul>
<li>Nanos-lite的<code>context_kload()</code>函数(框架代码未给出该函数的原型),
它进一步封装了创建内核上下文的过程: 调用<code>kcontext()</code>来创建上下文, 并把返回的指针记录到PCB的<code>cp</code>中</li>
<li>Nanos-lite的<code>schedule()</code>函数</li>
<li>在Nanos-lite收到<code>EVENT_YIELD</code>事件后, 调用<code>schedule()</code>并返回新的上下文</li>
</ul><p>Nanos-lite提供了一个测试函数<code>hello_fun()</code>(在<code>nanos-lite/src/proc.c</code>中定义),
你需要在<code>init_proc()</code>中创建两个以<code>hello_fun</code>为入口的上下文:</p><pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init_proc</span><span class="hljs-params">()</span> </span>{
  context_kload(&amp;pcb[<span class="hljs-number">0</span>], hello_fun, ???);
  context_kload(&amp;pcb[<span class="hljs-number">1</span>], hello_fun, ???);
  switch_boot_pcb();
}
</code></pre><p>其中调用<code>switch_boot_pcb()</code>是为了初始化<code>current</code>指针.
你可以自行约定用何种类型来解析参数<code>arg</code>(整数, 字符, 字符串, 指针等皆可),
然后修改<code>hello_fun()</code>中的输出代码, 来按照你约定的方式解析<code>arg</code>.
如果你的实现正确, 你将会看到<code>hello_fun()</code>会轮流输出不同参数的信息.</p></div></div>
<!-- -->
<div class="panel panel-success"><div class="panel-heading"><h5 class="panel-title" id="在native上进行上下文切换"><i class="fa fa-lightbulb-o"></i> 在native上进行上下文切换</h5></div><div class="panel-body"><p>由于native的AM在创建上下文的时候默认会打开中断, 为了成功运行native创建的内核线程,
你还需要在事件处理回调函数中识别出时钟中断事件. 我们会在PA4的最后介绍时钟中断相关的内容,
目前识别出时钟中断事件之后什么都不用做, 直接返回相应的上下文结构即可.</p></div></div>
<h2 id="用户进程">用户进程</h2>
<h3 id="创建用户进程上下文">创建用户进程上下文</h3>
<p>创建用户进程的上下文则需要一些额外的考量.
在PA3的批处理系统中, 我们在<code>naive_uload()</code>中直接通过函数调用转移到用户进程的代码,
那时候使用的还是内核区的栈, 万一发生了栈溢出, 确实会损坏操作系统的数据,
不过当时也只有一个用户进程在运行, 我们也就不追究了.
但在多道程序操作系统中, 系统中运行的进程就不止一个了,
如果让用户进程继续使用内核区的栈, 万一发生了栈溢出,
就会影响到其它进程的运行, 这是我们不希望看到的.</p>
<div class="panel panel-info"><div class="panel-heading"><h5 class="panel-title" id="如果内核线程发生了栈溢出-怎么办"><i class="fa fa-comment-o"></i> 如果内核线程发生了栈溢出, 怎么办?</h5></div><div class="panel-body"><p>如果能检测出来, 最好的方法就是触发kernel panic, 因为这时候内核的数据已经不再可信,
如果将一个被破坏的数据写回磁盘, 将会造成无法恢复的毁灭性损坏.</p><p>好消息是, 内核线程的正确性可以由内核开发人员来保证,
这至少要比保证那些来路不明的用户进程的正确性要简单多了.
而坏消息则是, 大部分的内核bug都是第三方驱动程序导致的:
栈溢出算是少见的了, 更多的是use-after-free, double-free, 还有难以捉摸的并发bug.
而面对海量的第三方驱动程序, 内核开发人员也难以逐一保证其正确性.
如果你想到一个可以提升驱动程序代码质量的方法, 那就是为计算机系统领域作出贡献了.</p></div></div>
<p>因此, 和内核线程不同, 用户进程的代码, 数据和堆栈都应该位于用户区,
而且需要保证用户进程能且只能访问自己的代码, 数据和堆栈.
为了区别开来, 我们把PCB中的栈称为内核栈, 位于用户区的栈称为用户栈.
于是我们需要一个有别于<code>kcontext()</code>的方式来创建用户进程的上下文,
为此AM额外准备了一个API <code>ucontext()</code>(在<code>abstract-machine/am/src/nemu/isa/$ISA/vme.c</code>中定义),
它的原型是</p>
<pre><code class="lang-c"><span class="hljs-function">Context* <span class="hljs-title">ucontext</span><span class="hljs-params">(AddrSpace *as, Area kstack, <span class="hljs-keyword">void</span> *entry)</span></span>;
</code></pre>
<p>其中, 参数<code>as</code>用于限制用户进程可以访问的内存, 我们在下一阶段才会使用, 目前可以忽略它;
<code>kstack</code>是内核栈, 用于分配上下文结构, <code>entry</code>则是用户进程的入口.
由于目前我们忽略了<code>as</code>参数, 所以<code>ucontext()</code>的实现和<code>kcontext()</code>几乎一样,
甚至比<code>kcontext()</code>更简单: 连参数都不需要传递.
不过你还是需要思考, 对于用户进程来说, 它需要一个什么样的状态来开始执行呢?</p>
<p>咦, 说好的用户栈呢? 事实上, 用户栈的分配是ISA无关的,
所以用户栈相关的部分就交给Nanos-lite来进行, <code>ucontext()</code>无需处理.
目前我们让Nanos-lite把<code>heap.end</code>作为用户进程的栈顶,
然后把这个栈顶赋给用户进程的栈指针寄存器就可以了.</p>
<p>哎呀, 栈指针寄存器可是ISA相关的, 在Nanos-lite里面不方便处理.
别着急, 还记得用户进程的那个<code>_start</code>吗? 在那里可以进行一些ISA相关的操作.
于是Nanos-lite和Navy作了一项约定: Nanos-lite把栈顶位置设置到GPRx中,
然后由Navy里面的<code>_start</code>来把栈顶位置真正设置到栈指针寄存器中.</p>
<p>Nanos-lite可以把上述工作封装到<code>context_uload()</code>函数中, 这样我们就可以加载用户进程了.
我们把其中一个<code>hello_fun()</code>内核线程替换成仙剑奇侠传:</p>
<pre><code class="lang-c">context_uload(&amp;pcb[<span class="hljs-number">1</span>], <span class="hljs-string">"/bin/pal"</span>);
</code></pre>
<p>然后我们还需要在<code>serial_write()</code>, <code>events_read()</code>
和<code>fb_write()</code>的开头调用<code>yield()</code>, 来模拟设备访问缓慢的情况.
添加之后, 访问设备时就要进行上下文切换, 从而实现多道程序系统的功能.</p>
<div class="panel panel-warning"><div class="panel-heading"><h5 class="panel-title" id="实现多道程序系统"><i class="fa fa-edit"></i> 实现多道程序系统</h5></div><div class="panel-body"><p>根据讲义的上述内容, 实现以下功能, 从而实现多道程序系统:</p><ul>
<li>VME的<code>ucontext()</code>函数</li>
<li>Nanos-lite的<code>context_uload()</code>函数(框架代码未给出该函数的原型)</li>
<li>在Navy的<code>_start</code>中设置正确的栈指针</li>
</ul><p>如果你的实现正确, 你将可以一边运行仙剑奇侠传的同时, 一边输出hello信息.
需要注意的是, 为了让AM native正确运行, 你也需要在Navy的<code>_start</code>中设置正确的栈指针.</p><p>思考一下, 如何验证仙剑奇侠传确实在使用用户栈而不是内核栈?</p></div></div>
<!-- -->
<div class="panel panel-info"><div class="panel-heading"><h5 class="panel-title" id="一山不能藏二虎"><i class="fa fa-question-circle"></i> 一山不能藏二虎?</h5></div><div class="panel-body"><p>尝试把<code>hello_fun()</code>换成Navy中的<code>hello</code>:</p><pre><code class="lang-diff"><span class="hljs-deletion">-context_kload(&amp;pcb[0], (void *)hello_fun, NULL);</span>
<span class="hljs-addition">+context_uload(&amp;pcb[0], "/bin/hello");</span>
 context_uload(&amp;pcb[1], "/bin/pal");
</code></pre><p>你发现了什么问题? 为什么会这样?
思考一下, 答案会在下一阶段揭晓!</p></div></div>
<h3 id="用户进程的参数">用户进程的参数</h3>
<p>我们在实现内核线程的时候, 给它传递了一个<code>arg</code>参数.
事实上, 用户进程也可以有自己的参数, 那就是你在程序设计课上学习过的<code>argc</code>和<code>argv</code>了,
还有一个你也许不怎么熟悉的<code>envp</code>. <code>envp</code>是环境变量指针, 它指向一个字符串数组,
字符串的格式都是形如<code>xxx=yyy</code>, 表示有一个名为<code>xxx</code>的变量, 它的值为<code>yyy</code>.
我们在PA0中通过<code>init.sh</code>初始化PA项目的时候, 它会在<code>.bashrc</code>文件中定义一些环境变量, 比如<code>AM_HOME</code>.
当我们编译FCEUX的时候, <code>make</code>程序就会解析<code>fceux-am/Makefile</code>中的内容,
当遇到</p>
<pre><code class="lang-make">include $(AM_HOME)/Makefile
</code></pre>
<p>的时候, 就会尝试通过<code>getenv()</code>这个库函数在<code>envp</code>指向的字符串数组里面寻找是否有形如
<code>AM_HOME=yyy</code>的字符串, 如果有, 就返回<code>yyy</code>. 如果<code>AM_HOME</code>指向了正确的路径,
<code>make</code>程序就可以找到<code>abstract-machine</code>项目中的<code>Makefile</code>文件并包含进来.</p>
<p>事实上, <code>main()</code>函数完整的原型应该是</p>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[], <span class="hljs-keyword">char</span> *envp[])</span></span>;
</code></pre>
<p>那么, 当我们在终端里面键入</p>
<pre><code class="lang-bash">make ARCH=x86-nemu run
</code></pre>
<p>的时候, <code>ARCH=x86-nemu</code>和<code>run</code>这两个参数以及环境变量都是怎么传递给<code>make</code>程序的<code>main()</code>函数的呢?</p>
<p>既然用户进程是操作系统来创建的, 很自然参数和环境变量的传递就需要由操作系统来负责.
最适合存放参数和环境变量的地方就是用户栈了, 因为在首次切换到用户进程的时候,
用户栈上的内容就已经可以被用户进程访问. 于是操作系统在加载用户进程的时候,
还需要负责把<code>argc/argv/envp</code>以及相应的字符串放在用户栈中,
并把它们的存放方式和位置作为和用户进程的约定之一,
这样用户进程在<code>_start</code>中就可以根据约定访问它们了.</p>
<p>这项约定其实属于ABI的内容, ABI手册有一节Process Initialization的内容,
里面详细约定了操作系统需要为用户进程的初始化提供哪些信息.
不过在我们的Project-N系统里面, 我们只需要一个简化版的Process Initialization就够了:
操作系统将<code>argc/argv/envp</code>及其相关内容放置到用户栈上, 然后将GPRx设置为<code>argc</code>所在的地址.</p>
<pre><code>|               |
+---------------+ &lt;---- ustack.end
|  Unspecified  |
+---------------+
|               | &lt;----------+
|    string     | &lt;--------+ |
|     area      | &lt;------+ | |
|               | &lt;----+ | | |
|               | &lt;--+ | | | |
+---------------+    | | | | |
|  Unspecified  |    | | | | |
+---------------+    | | | | |
|     NULL      |    | | | | |
+---------------+    | | | | |
|    ......     |    | | | | |
+---------------+    | | | | |
|    envp[1]    | ---+ | | | |
+---------------+      | | | |
|    envp[0]    | -----+ | | |
+---------------+        | | |
|     NULL      |        | | |
+---------------+        | | |
| argv[argc-1]  | -------+ | |
+---------------+          | |
|    ......     |          | |
+---------------+          | |
|    argv[1]    | ---------+ |
+---------------+            |
|    argv[0]    | -----------+
+---------------+
|      argc     |
+---------------+ &lt;---- cp-&gt;GPRx
|               |
</code></pre><p>上图把这些参数分成两部分, 一部分是字符串区域(string area),
另一部分是<code>argv/envp</code>这两个字符串指针数组, 数组中的每一个元素是一个字符串指针,
而这些字符串指针都会指向字符串区域中的某个字符串.
此外, 上图中的<code>Unspecified</code>表示一段任意长度(也可为0)的间隔,
字符串区域中各个字符串的顺序也不作要求, 只要用户进程可以通过<code>argv/envp</code>访问到正确的字符串即可.
这些参数的放置格式与ABI手册中的描述非常类似, 你也可以参考ICS课本第七章的某个图.</p>
<div class="panel panel-info"><div class="panel-heading"><h5 class="panel-title" id="阅读abi手册-理解计算机系统"><i class="fa fa-comment-o"></i> 阅读ABI手册, 理解计算机系统</h5></div><div class="panel-body"><p>事实上, ABI手册是ISA, OS, 编译器, 运行时环境, C语言和用户进程的桥梁, 非常值得大家去阅读.
ICS课本上那些让你摸不着头脑的约定, 大部分也是出自ABI手册.
Linux上遵守的ABI是System V ABI, 它又分为两部分,
一部分是和处理器无关的generic ABI(gABI), 例如ELF格式, 动态连接, 文件系统结构等;
另一部分是和处理器相关的processor specific ABI(psABI), 例如调用约定, 操作系统接口, 程序加载等.
你至少也应该去看看ABI手册的目录, 翻一下正文部分的图, 这样你就会对ABI手册有一个大致的了解.
如果你愿意深入推敲一下"为什么这样约定", 那就是真正的"深入理解计算机系统了".</p></div></div>
<p>根据这一约定, 你还需要修改Navy中<code>_start</code>的代码, 把<code>argc</code>的地址作为参数传递给<code>call_main()</code>.
然后修改<code>call_main()</code>的代码, 让它解析出真正的<code>argc/argv/envp</code>, 并调用<code>main()</code>:</p>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">call_main</span><span class="hljs-params">(uintptr_t *args)</span> </span>{
  argc = ???
  argv = ???
  envp = ???
  environ = envp;
  <span class="hljs-built_in">exit</span>(main(argc, argv, envp));
  assert(<span class="hljs-number">0</span>);
}
</code></pre>
<p>这样以后, 用户进程就可以接收到属于它的参数了.</p>
<div class="panel panel-warning"><div class="panel-heading"><h5 class="panel-title" id="给用户进程传递参数"><i class="fa fa-edit"></i> 给用户进程传递参数</h5></div><div class="panel-body"><p>这个任务的本质是一个指针相关的编程练习,
不过你需要注意编写可移植的代码, 因为<code>call_main()</code>是被各种ISA所共享的.
然后修改仙剑奇侠传的少量代码, 如果它接收到一个<code>--skip</code>参数,
就跳过片头商标动画的播放, 否则不跳过. 实现这个功能将有利于加速仙剑奇侠传的测试.
商标动画的播放从代码逻辑上距离<code>main()</code>函数并不远, 于是就交给你来RTFSC吧.</p><p>不过为了给用户进程传递参数, 你还需要修改<code>context_uload()</code>的原型:</p><pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">context_uload</span><span class="hljs-params">(PCB *pcb, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename, <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> argv[], <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> envp[])</span></span>;
</code></pre><p>这样你就可以在<code>init_proc()</code>中直接给出用户进程的参数来测试了:
在创建仙剑奇侠传用户进程的时候给出<code>--skip</code>参数, 你需要观察到仙剑奇侠传确实跳过了商标动画.
目前我们的测试程序中不会用到环境变量, 所以不必传递真实的环境变量字符串.
至于实参应该写什么, 这又是一个指针相关的问题, 就交给你来解决吧.</p></div></div>
<p>让操作系统为每一个用户进程手动设定参数是一件不现实的事情,
因为用户进程的参数还是应该由用户来指定的.
于是最好能有一个方法能把用户指定的参数告诉操作系统,
让操作系统来把指定的参数放到新进程的用户栈里面.
这个方法当然就是系统调用<code>SYS_execve</code>啦, 如果你去看<code>man</code>, 你会发现它的原型是</p>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">execve</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename, <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> argv[], <span class="hljs-keyword">char</span> *<span class="hljs-keyword">const</span> envp[])</span></span>;
</code></pre>
<div class="panel panel-info"><div class="panel-heading"><h5 class="panel-title" id="为什么少了一个const"><i class="fa fa-question-circle"></i> 为什么少了一个const?</h5></div><div class="panel-body"><p>在<code>main()</code>函数中, <code>argv</code>和<code>envp</code>的类型是<code>char * []</code>,
而在<code>execve()</code>函数中, 它们的类型则是<code>char *const []</code>.
从这一差异来看, <code>main()</code>函数中<code>argv</code>和<code>envp</code>所指向的字符串是可写的,
你知道为什么会这样吗?</p></div></div>
<p>为了实现带参数的<code>SYS_execve</code>, 我们可以在<code>sys_execve()</code>中直接调用<code>context_uload()</code>.
但我们还需要考虑如下的一些细节, 为了方便描述,
我们假设用户进程A将要通过<code>SYS_execve</code>来执行另一个新程序B.</p>
<ul>
<li>如何在A的执行流中创建用户进程B?</li>
<li>如何结束A的执行流?</li>
</ul>
<p>为了回答第一个问题, 我们需要回顾创建用户进程B需要进行哪些操作.
首先是在PCB的内核栈中创建B的上下文结构, 这个过程是安全的, 因为当前进程的内核栈是空的.
接下来就是要在用户栈中放置用户进程B的参数.
但这会涉及到一个新的问题: 我们是否还能复用位于<code>heap.end</code>附近的同一个用户栈?</p>
<p>为了探究这个问题, 我们需要了解当Nanos-lite尝试通过<code>SYS_execve</code>加载B时, A的用户栈里面已经有什么内容.
我们可以从栈底(<code>heap.end</code>)到栈顶(栈指针<code>sp</code>当前的位置)列出用户栈中的内容:</p>
<ul>
<li>Nanos-lite之前为A传递的用户进程参数(<code>argc/argv/envp</code>)</li>
<li>A从<code>_start</code>开始进行函数调用的栈帧, 这个栈帧会一直生长, 直到调用了libos中的<code>execve()</code></li>
<li>CTE保存的上下文结构, 这是由于A在<code>execve()</code>中执行了系统调用自陷指令导致的</li>
<li>Nanos-lite从<code>__am_irq_handle()</code>开始进行函数调用的栈帧,
这个栈帧会一直生长, 直到调用了<code>SYS_execve</code>的系统调用处理函数</li>
</ul>
<p>通过上述分析, 我们得出一个重要的结论: 在加载B时, Nanos-lite使用的是A的用户栈!
这意味着在A的执行流结束之前, A的用户栈是不能被破坏的.
因此<code>heap.end</code>附近的用户栈是不能被B复用的, 我们应该申请一段新的内存作为B的用户栈,
来让Nanos-lite把B的参数放置到这个新分配的用户栈里面.</p>
<p>为了实现这一点, 我们可以让<code>context_uload()</code>统一通过调用<code>new_page()</code>函数来获得用户栈的内存空间.
<code>new_page()</code>函数在<code>nanos-lite/src/mm.c</code>中定义, 它会通过一个<code>pf</code>指针来管理堆区,
用于分配一段大小为<code>nr_page * 4KB</code>的连续内存区域, 并返回这段区域的首地址.
我们让<code>context_uload()</code>通过<code>new_page()</code>来分配32KB的内存作为用户栈,
这对PA中的用户程序来说已经足够使用了.
此外为了简化, 我们在PA中无需实现<code>free_page()</code>.</p>
<div class="panel panel-info"><div class="panel-heading"><h5 class="panel-title" id="操作系统的内存管理"><i class="fa fa-comment-o"></i> 操作系统的内存管理</h5></div><div class="panel-body"><p>我们知道klib中的<code>malloc()</code>函数也可以进行堆区的管理, 使得AM应用可以方便地进行动态内存申请.
但操作系统作为一个特殊的AM应用, 很多时候对动态内存申请却有更严格的要求,
例如申请一段起始地址是4KB整数倍的内存区域, <code>malloc()</code>通常不能满足这样的要求.
因此操作系统一般都会自己来管理堆区, 而不会调用klib中的<code>malloc()</code>.
在操作系统中管理堆区是MM(Memory Manager)模块的工作, 我们会在后续内容中进一步介绍它.</p></div></div>
<p>最后, 为了结束A的执行流, 我们可以在创建B的上下文之后,
通过<code>switch_boot_pcb()</code>修改当前的<code>current</code>指针, 然后调用<code>yield()</code>来强制触发进程调度.
这样以后, A的执行流就不会再被调度, 等到下一次调度的时候, 就可以恢复并执行B了.</p>
<div class="panel panel-warning"><div class="panel-heading"><h5 class="panel-title" id="实现带参数的execve"><i class="fa fa-edit"></i> 实现带参数的execve()</h5></div><div class="panel-body"><p>根据上述讲义内容, 实现带参数的<code>execve()</code>. 有一些细节我们并没有完全给出,
例如调用<code>context_uload()</code>的<code>pcb</code>参数应该传入什么内容, 这个问题就交给你来思考吧!</p><p>实现后, 运行以下程序:</p><ul>
<li>测试程序<code>navy-apps/tests/exec-test</code>, 它会以参数递增的方式不断地执行自身.
不过由于我们没有实现堆区内存的回收, <code>exec-test</code>在运行一段时间之后,
<code>new_page()</code>就会把<code>0x3000000</code>/<code>0x83000000</code>附近的内存分配出去, 导致用户进程的代码段被覆盖.
目前我们无法修复这一问题, 你只需要看到<code>exec-test</code>可以正确运行一段时间即可.</li>
<li>MENU开机菜单.</li>
<li>完善NTerm的內建Shell, 使得它可以解析输入的参数, 并传递给启动的程序.
例如可以在NTerm中键入<code>pal --skip</code>来运行仙剑奇侠传并跳过商标动画.</li>
</ul></div></div>
<h3 id="运行busybox">运行Busybox</h3>
<p>我们已经成功运行了NTerm, 但却没多少Shell工具可以运行.
<a href="https://www.busybox.net/about.html" target="_blank">Busybox</a>正是用来解决这个问题的, 它是一个精简版Shell工具的集合,
包含了大部分常用命令的常用功能.
噢, 你平时在Linux中使用命令行的经历, 很快就可以在你自己构建的计算机系统里面呈现了!</p>
<p>Navy的框架代码已经准备了Busybox的编译脚本, 首次编译Busybox时脚本会自动克隆项目,
并使用框架代码提供的配置文件. Busybox中包含很多小工具, 你可以通过</p>
<pre><code>make menuconfig
</code></pre><p>来打开一个配置菜单来查看它们(但不要保存对配置的修改).
框架代码提供的配置文件默认只选中了很少的工具,
这是因为大部分工具都需要更多系统调用的支持才能运行, 因此我们无法在Nanos-lite上运行它们.</p>
<p>Busybox会把其中的Shell工具链接成一个ELF可执行文件, 而不是像Ubuntu/Debian等发行版中的Shell工具那样,
每个工具都是独立的ELF可执行文件. Busybox的<code>main()</code>函数会根据传入的参数来调用相应工具的功能:</p>
<pre><code class="lang-c"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">"cat"</span>) == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> cat_main(argc, argv);
<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">"ls"</span>) == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> ls_main(argc, argv);
<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">"wc"</span>) == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> wc_main(argc, argv);
<span class="hljs-comment">// ......</span>
</code></pre>
<p>Busybox提供了一个简单的安装脚本, 通过创建一系列的软链接来让用户方便地使用这些小工具:</p>
<pre><code>$ ls -lh navy-apps/fsimg/bin
total 1.6M
lrwxrwxrwx 1 yzh yzh    7 Dec  9 12:12 base64 -&gt; busybox
-rwxr-xr-x 1 yzh yzh 161K Oct 21 12:11 bird
-rwxr-xr-x 1 yzh yzh 126K Dec  9 12:12 busybox
lrwxrwxrwx 1 yzh yzh    7 Dec  9 12:12 cat -&gt; busybox
-rwxr-xr-x 1 yzh yzh  33K Oct 20 20:43 cpp-test
-rwxr-xr-x 1 yzh yzh  29K Dec  9 12:12 dummy
lrwxrwxrwx 1 yzh yzh    7 Dec  9 12:12 echo -&gt; busybox
lrwxrwxrwx 1 yzh yzh    7 Dec  9 12:12 ed -&gt; busybox
lrwxrwxrwx 1 yzh yzh    7 Dec  9 12:12 false -&gt; busybox
-rwxr-xr-x 1 yzh yzh  33K Dec  9 12:12 hello
-rwxr-xr-x 1 yzh yzh  81K Dec  9 12:12 menu
-rwxr-xr-x 1 yzh yzh  91K Dec  9 12:12 nterm
-rwxr-xr-x 1 yzh yzh 586K Dec  9 12:12 onscripter
-rwxr-xr-x 1 yzh yzh 390K Dec  9 12:12 pal
lrwxrwxrwx 1 yzh yzh    7 Dec  9 12:12 printenv -&gt; busybox
lrwxrwxrwx 1 yzh yzh    7 Dec  9 12:12 sleep -&gt; busybox
lrwxrwxrwx 1 yzh yzh    7 Dec  9 12:12 true -&gt; busybox
</code></pre><p>这样以后, 我们键入<code>cat</code>命令, 实际上是执行<code>/bin/busybox</code>, 来让它执行链接到Busybox的<code>cat_main()</code>函数.</p>
<div class="panel panel-warning"><div class="panel-heading"><h5 class="panel-title" id="运行busybox"><i class="fa fa-edit"></i> 运行Busybox</h5></div><div class="panel-body"><p>尝试通过NTerm运行Busybox中的一些简单命令, 比如<code>cat</code>和<code>printenv</code>等.
如果你不清楚这些命令的用法, 可以通过<code>man</code>来查阅它们.
注意不要让这些命令的输出淹没在<code>hello_fun()</code>打印的信息中,
为此你可能需要调整<code>hello_fun()</code>打印信息的频率.</p></div></div>
<p>有一些工具并不是放在<code>/bin</code>目录下, 而是放在<code>/usr/bin</code>目录下, 例如<code>wc</code>.
为了不必输入完整的路径, 我们可以把<code>/usr/bin</code>也加入到<code>PATH</code>环境变量中.
不同的路径通过<code>:</code>进行分隔, 具体格式可以参考在Linux上运行<code>echo $PATH</code>命令的结果.
这样以后, 我们就可以通过一个库函数<code>execvp()</code>来尝试遍历<code>PATH</code>中的所有路径,
直到找到一个存在的可执行文件为止, 找到之后就会调用<code>SYS_execve</code>.
你可以通过阅读<code>navy-apps/libs/libc/src/posix/execvp.c</code>来了解这一功能是如何实现的.</p>
<p>不过为了遍历<code>PATH</code>中的路径, <code>execvp()</code>可能会尝试执行一个不存在的用户程序, 例如<code>/bin/wc</code>.
因此Nanos-lite在处理<code>SYS_execve</code>系统调用的时候就需要检查将要执行的程序是否存在,
如果不存在, 就需要返回一个错误码.
我们可以通过<code>fs_open()</code>来进行检查, 如果需要打开的文件不存在,
就返回一个错误的值, 此时<code>SYS_execve</code>返回<code>-2</code>.
另一方面, libos中的<code>execve()</code>还需要检查系统调用的返回值:
如果系统调用的返回值小于0, 则通常表示系统调用失败, 此时需要将系统调用返回值取负,
作为失败原因设置到一个全局的外部变量<code>errno</code>中, 然后返回<code>-1</code>.</p>
<div class="panel panel-info"><div class="panel-heading"><h5 class="panel-title" id="-2和errno"><i class="fa fa-comment-o"></i> -2和errno</h5></div><div class="panel-body"><p><code>errno</code>是C标准定义的, 运行时环境中的一个全局变量,
用于存放最近一次失败的系统调用或库函数调用的错误码.
你可以通过运行<code>errno -l</code>命令(需要通过<code>apt-get</code>安装<code>moreutils</code>包)
来查看所有的错误码及其含义, 你应该能看到错误码<code>2</code>是你比较熟悉的一种错误.
关于<code>errno</code>全局变量的更多信息, 可以参考<code>man 3 errno</code>.</p></div></div>
<!-- -->
<div class="panel panel-warning"><div class="panel-heading"><h5 class="panel-title" id="运行busybox2"><i class="fa fa-edit"></i> 运行Busybox(2)</h5></div><div class="panel-body"><p>实现上述内容, 让<code>execvp()</code>支持<code>PATH</code>的遍历.
然后尝试通过NTerm运行<code>wc</code>等位于<code>/usr/bin</code>目录下的命令,
例如<code>wc /share/games/bird/atlas.txt</code>.
你可以通过在Linux上运行相应命令来查看结果是否正确.
此外, 你可以通过阅读<code>execvp()</code>的代码来帮助你判断返回值的设置是否正确.</p></div></div>
<p>虽然目前我们只能在Nanos-lite上运行很少部分的Busybox工具,
但你基本上在自己构建的计算机系统里面呈现了与你平时使用Linux命令行工具非常相似的一幕.
我们把这件事放到Project-N的系统栈里面, 就是为了能够让你明白,
你平时键入命令的时候计算机系统的各个抽象层都做了些什么:</p>
<ul>
<li>终端如何读取用户的按键?</li>
<li>Shell如何进行命令的解析?</li>
<li>库函数如何根据命令解析出的字符串搜索到可执行文件?</li>
<li>操作系统如何加载执行一个可执行文件?</li>
<li>......</li>
</ul>
<p>虽然Project-N和真实的Linux系统还有很大的差异,
但独立完成PA已经可以很大程度上帮助你消除对"程序如何在计算机上运行"的神秘感.</p>
<div class="panel panel-success"><div class="panel-heading"><h5 class="panel-title" id="温馨提示"><i class="fa fa-lightbulb-o"></i> 温馨提示</h5></div><div class="panel-body"><p>PA4阶段1到此结束.</p></div></div>
<footer class="page-footer-ex"> <span class="page-footer-ex-copyright"> By <a href="https://sashimi-yzh.github.io/" target="_blank">Zihao Yu</a>, 采用<a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank">知识共享 署名-非商业性使用-相同方式共享 3.0 中国大陆 许可协议</a>发布 </span>            <span class="page-footer-ex-footer-update"> 此页面修订于:  2023-10-04 21:53:51 </span> </footer>
</section>
</div>
<div class="search-results">
<div class="has-results">
<h1 class="search-results-title"><span class="search-results-count"></span> results matching "<span class="search-query"></span>"</h1>
<ul class="search-results-list"></ul>
</div>
<div class="no-results">
<h1 class="search-results-title">No results matching "<span class="search-query"></span>"</h1>
</div>
</div>
</div>
</div>
</div>
</div>
<a aria-label="Previous page: PA4 - 虚实交错的魔法: 分时多任务" class="navigation navigation-prev" href="PA4.html">
<i class="fa fa-angle-left"></i>
</a>
<a aria-label="Next page: 虚实交错的魔法" class="navigation navigation-next" href="4.2.html">
<i class="fa fa-angle-right"></i>
</a>
</div>
<script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"多道程序","level":"1.6.1","depth":2,"next":{"title":"虚实交错的魔法","level":"1.6.2","depth":2,"path":"4.2.md","ref":"4.2.md","articles":[]},"previous":{"title":"PA4 - 虚实交错的魔法: 分时多任务","level":"1.6","depth":1,"path":"PA4.md","ref":"PA4.md","articles":[{"title":"多道程序","level":"1.6.1","depth":2,"path":"4.1.md","ref":"4.1.md","articles":[]},{"title":"虚实交错的魔法","level":"1.6.2","depth":2,"path":"4.2.md","ref":"4.2.md","articles":[]},{"title":"超越容量的界限","level":"1.6.3","depth":2,"path":"4.3.md","ref":"4.3.md","articles":[]},{"title":"来自外部的声音","level":"1.6.4","depth":2,"path":"4.4.md","ref":"4.4.md","articles":[]},{"title":"编写不朽的传奇","level":"1.6.5","depth":2,"path":"4.5.md","ref":"4.5.md","articles":[]}]},"dir":"ltr"},"config":{"gitbook":"3.x.x","theme":"default","variables":{},"plugins":["theme-comscore","intopic-toc","localized-footer","page-footer-ex","callouts"],"pluginsConfig":{"callouts":{"option":{"alert":"info","picto":"fa-edit"},"flag":{"alert":"success","picto":"fa-flag"},"question":{"alert":"info","picto":"fa-question-circle"},"info":{"alert":"info","picto":"fa-info-circle"},"todo":{"alert":"warning","picto":"fa-edit"},"caution":{"alert":"danger","picto":"fa-bullhorn"},"danger":{"alert":"danger","picto":"fa-exclamation"},"showTypeInHeader":false},"intopic-toc":{"isCollapsed":false,"isScrollspyActive":true,"label":"导航","maxDepth":6,"mode":"nested","selector":".markdown-section h2, .markdown-section h3, .markdown-section h4","visible":true},"page-footer-ex":{"copyright":"By [Zihao Yu](https://sashimi-yzh.github.io/), 采用[知识共享 署名-非商业性使用-相同方式共享 3.0 中国大陆 许可协议](http://creativecommons.org/licenses/by-nc-sa/3.0/cn/)发布","markdown":true,"update_format":"YYYY-MM-DD HH:mm:ss","update_label":"此页面修订于: "},"search":{},"localized-footer":{"filename":"FOOTER.md","hline":"true"},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"theme":"white","family":"sans","size":2},"highlight":{},"theme-comscore":{},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles.css","pdf":"styles.css"}},"file":{"path":"4.1.md","mtime":"2023-10-04T13:53:51.417Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2023-12-05T03:26:43.464Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>
{% endblock %}