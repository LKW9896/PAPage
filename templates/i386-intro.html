{% extends 'base.html' %}
{% block head %}
<title>i386手册指令集阅读指南 · GitBook</title>

<link href="changelog.html" rel="prev"/>
{% endblock %}
{% block body %}
<div class="book">
<div class="book-summary">
<div id="book-search-input" role="search">
<input placeholder="Type to search" type="text"/>
</div>
<nav role="navigation">
<ul class="summary">
<li class="chapter" data-level="1.1" data-path="index.html">
<a href="index.html">
            
                    
                    Introduction
            
                </a>
</li>
<li class="chapter" data-level="1.2" data-path="PA0.html">
<a href="PA0.html">
            
                    
                    PA0 - 世界诞生的前夜: 开发环境配置
            
                </a>
<ul class="articles">
<li class="chapter" data-level="1.2.1" data-path="0.1.html">
<a href="0.1.html">
            
                    
                    Installing GNU/Linux
            
                </a>
</li>
<li class="chapter" data-level="1.2.2" data-path="0.2.html">
<a href="0.2.html">
            
                    
                    First Exploration with GNU/Linux
            
                </a>
</li>
<li class="chapter" data-level="1.2.3" data-path="0.3.html">
<a href="0.3.html">
            
                    
                    Installing Tools
            
                </a>
</li>
<li class="chapter" data-level="1.2.4" data-path="0.4.html">
<a href="0.4.html">
            
                    
                    Configuring vim
            
                </a>
</li>
<li class="chapter" data-level="1.2.5" data-path="0.5.html">
<a href="0.5.html">
            
                    
                    More Exploration
            
                </a>
</li>
<li class="chapter" data-level="1.2.6" data-path="0.6.html">
<a href="0.6.html">
            
                    
                    Getting Source Code for PAs
            
                </a>
</li>
</ul>
</li>
<li class="chapter" data-level="1.3" data-path="PA1.html">
<a href="PA1.html">
            
                    
                    PA1 - 开天辟地的篇章: 最简单的计算机
            
                </a>
<ul class="articles">
<li class="chapter" data-level="1.3.1" data-path="1.1.html">
<a href="1.1.html">
            
                    
                    在开始愉快的PA之旅之前
            
                </a>
</li>
<li class="chapter" data-level="1.3.2" data-path="1.2.html">
<a href="1.2.html">
            
                    
                    开天辟地的篇章
            
                </a>
</li>
<li class="chapter" data-level="1.3.3" data-path="1.3.html">
<a href="1.3.html">
            
                    
                    RTFSC
            
                </a>
</li>
<li class="chapter" data-level="1.3.4" data-path="1.4.html">
<a href="1.4.html">
            
                    
                    基础设施
            
                </a>
</li>
<li class="chapter" data-level="1.3.5" data-path="1.5.html">
<a href="1.5.html">
            
                    
                    表达式求值
            
                </a>
</li>
<li class="chapter" data-level="1.3.6" data-path="1.6.html">
<a href="1.6.html">
            
                    
                    监视点
            
                </a>
</li>
<li class="chapter" data-level="1.3.7" data-path="1.7.html">
<a href="1.7.html">
            
                    
                    如何阅读手册
            
                </a>
</li>
</ul>
</li>
<li class="chapter" data-level="1.4" data-path="PA2.html">
<a href="PA2.html">
            
                    
                    PA2 - 简单复杂的机器: 冯诺依曼计算机系统
            
                </a>
<ul class="articles">
<li class="chapter" data-level="1.4.1" data-path="2.1.html">
<a href="2.1.html">
            
                    
                    不停计算的机器
            
                </a>
</li>
<li class="chapter" data-level="1.4.2" data-path="2.2.html">
<a href="2.2.html">
            
                    
                    RTFSC(2)
            
                </a>
</li>
<li class="chapter" data-level="1.4.3" data-path="2.3.html">
<a href="2.3.html">
            
                    
                    程序, 运行时环境与AM
            
                </a>
</li>
<li class="chapter" data-level="1.4.4" data-path="2.4.html">
<a href="2.4.html">
            
                    
                    基础设施(2)
            
                </a>
</li>
<li class="chapter" data-level="1.4.5" data-path="2.5.html">
<a href="2.5.html">
            
                    
                    输入输出
            
                </a>
</li>
</ul>
</li>
<li class="chapter" data-level="1.5" data-path="PA3.html">
<a href="PA3.html">
            
                    
                    PA3 - 穿越时空的旅程: 批处理系统
            
                </a>
<ul class="articles">
<li class="chapter" data-level="1.5.1" data-path="3.1.html">
<a href="3.1.html">
            
                    
                    最简单的操作系统
            
                </a>
</li>
<li class="chapter" data-level="1.5.2" data-path="3.2.html">
<a href="3.2.html">
            
                    
                    穿越时空的旅程
            
                </a>
</li>
<li class="chapter" data-level="1.5.3" data-path="3.3.html">
<a href="3.3.html">
            
                    
                    用户程序和系统调用
            
                </a>
</li>
<li class="chapter" data-level="1.5.4" data-path="3.4.html">
<a href="3.4.html">
            
                    
                    文件系统
            
                </a>
</li>
<li class="chapter" data-level="1.5.5" data-path="3.5.html">
<a href="3.5.html">
            
                    
                    精彩纷呈的应用程序
            
                </a>
</li>
</ul>
</li>
<li class="chapter" data-level="1.6" data-path="PA4.html">
<a href="PA4.html">
            
                    
                    PA4 - 虚实交错的魔法: 分时多任务
            
                </a>
<ul class="articles">
<li class="chapter" data-level="1.6.1" data-path="4.1.html">
<a href="4.1.html">
            
                    
                    多道程序
            
                </a>
</li>
<li class="chapter" data-level="1.6.2" data-path="4.2.html">
<a href="4.2.html">
            
                    
                    虚实交错的魔法
            
                </a>
</li>
<li class="chapter" data-level="1.6.3" data-path="4.3.html">
<a href="4.3.html">
            
                    
                    超越容量的界限
            
                </a>
</li>
<li class="chapter" data-level="1.6.4" data-path="4.4.html">
<a href="4.4.html">
            
                    
                    来自外部的声音
            
                </a>
</li>
<li class="chapter" data-level="1.6.5" data-path="4.5.html">
<a href="4.5.html">
            
                    
                    编写不朽的传奇
            
                </a>
</li>
</ul>
</li>
<li class="chapter" data-level="1.7" data-path="blank.html">
<a href="blank.html">
            
                    
                    杂项
            
                </a>
<ul class="articles">
<li class="chapter" data-level="1.7.1" data-path="FAQ.html">
<a href="FAQ.html">
            
                    
                    常见问题(FAQ)
            
                </a>
</li>
<li class="chapter" data-level="1.7.2" data-path="why.html">
<a href="why.html">
            
                    
                    为什么要学习计算机系统基础
            
                </a>
</li>
<li class="chapter" data-level="1.7.3" data-path="linux.html">
<a href="linux.html">
            
                    
                    Linux入门教程
            
                </a>
</li>
<li class="chapter" data-level="1.7.4" data-path="man.html">
<a href="man.html">
            
                    
                    man入门教程
            
                </a>
</li>
<li class="chapter" data-level="1.7.5" data-path="git.html">
<a href="git.html">
            
                    
                    git入门教程
            
                </a>
</li>
<li class="chapter" data-level="1.7.6" data-path="nemu-isa-api.html">
<a href="nemu-isa-api.html">
            
                    
                    NEMU ISA相关API说明文档
            
                </a>
</li>
<li class="chapter" data-level="1.7.7" data-path="changelog.html">
<a href="changelog.html">
            
                    
                    更新日志
            
                </a>
</li>
<li class="chapter active" data-level="1.7.8" data-path="i386-intro.html">
<a href="i386-intro.html">
            
                    
                    i386手册指令集阅读指南
            
                </a>
</li>
</ul>
</li>
<li class="divider"></li>
<li>
<a class="gitbook-link" href="https://www.gitbook.com" target="blank">
            Published with GitBook
        </a>
</li>
</ul>
</nav>
</div>
<div class="book-body">
<div class="body-inner">
<div class="book-header" role="navigation">
<!-- Title -->
<h1>
<i class="fa fa-circle-o-notch fa-spin"></i>
<a href=".">i386手册指令集阅读指南</a>
</h1>
</div>
<div class="page-wrapper" role="main" tabindex="-1">
<div class="page-inner">
<div id="book-search-results">
<div class="search-noresults">
<section class="normal markdown-section">
<h1 id="x86指令系统简介">x86指令系统简介</h1>
<p>i386手册有一章专门列出了所有指令的细节, 附录中的opcode map也很有用.
在这里, 我们先对x86指令系统作一些简单的梳理.
当你对x86指令系统有任何疑惑时, 请查阅i386手册, 关于指令系统的一切细节都在里面.</p>
<div class="panel panel-danger"><div class="panel-heading"><h5 class="panel-title" id="i386手册勘误"><i class="fa fa-exclamation"></i> i386手册勘误</h5></div><div class="panel-body"><p>由于PDF版本的i386手册的印刷错误较多, 一定程度上影响理解,
我们在github上开放了一个<a href="https://github.com/NJU-ProjectN/i386-manual" target="_blank">repo</a>, 用于提供修复印刷错误的版本.
同时我们也为修复错误后的版本提供在线的<a href="https://nju-projectn.github.io/i386-manual/toc.htm" target="_blank">HTML版本</a>.</p><p>如果你在做实验的过程中也发现了新的错误, 欢迎帮助我们修复这些错误.</p></div></div>
<h2 id="指令格式">指令格式</h2>
<p>x86指令的一般格式如下:</p>
<pre><code>+-----------+-----------+-----------+--------+------+------+------+------------+-----------+
|instruction| address-  |  operand- |segment |opcode|ModR/M| SIB  |displacement| immediate |
|  prefix   |size prefix|size prefix|override|      |      |      |            |           |
|-----------+-----------+-----------+--------+------+------+------+------------+-----------|
|   0 OR 1  |  0 OR 1   |   0 OR 1  | 0 OR 1 |1 OR 2|0 OR 1|0 OR 1| 0,1,2 OR 4 |0,1,2 OR 4 |
| - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -|
|                                     number of bytes                                      |
+------------------------------------------------------------------------------------------+
</code></pre><p>除了opcode(操作码)必定出现之外, 其余组成部分可能不出现,
而对于某些组成部分, 其长度并不是固定的.
但给定一条具体指令的二进制形式, 其组成部分的划分是有办法确定的,
不会产生歧义(即把一串比特串看成指令的时候, 不会出现两种不同的解释). 例如对于以下指令:</p>
<pre><code>100017:    66 c7 84 99 00 e0 ff ff 01 00      movw   $0x1,-0x2000(%ecx,%ebx,4)
</code></pre><p>其组成部分的划分如下:</p>
<pre><code>+-----------+-----------+-----------+--------+------+------+------+------------+-----------+
|instruction| address-  |  operand- |segment |opcode|ModR/M| SIB  |displacement| immediate |
|  prefix   |size prefix|size prefix|override|      |      |      |            |           |
|-----------+-----------+-----------+--------+------+------+------+------------+-----------|
|                            66                 c7     84     99    00 e0 ff ff    01 00   |
+------------------------------------------------------------------------------------------+
</code></pre><p>凭什么<code>0x84</code>要被解释成<code>ModR/M</code>字节呢?
这是由<code>opcode</code>决定的, <code>opcode</code>决定了这是什么指令的什么形式, 同时也决定了<code>opcode</code>之后的比特串如何解释.
如果你要问是谁来决定<code>opcode</code>, 那你就得去问Intel了.</p>
<p>PA中的x86经过简化, <code>address-size prefix</code>和<code>segment override prefix</code>都不会用到,
因此NEMU也不需要实现这两者的功能.</p>
<div class="panel panel-info"><div class="panel-heading"><h5 class="panel-title" id="编码的艺术"><i class="fa fa-question-circle"></i> 编码的艺术</h5></div><div class="panel-body"><p>对于以下5个集合:</p><ol>
<li>所有<code>instruction prefix</code></li>
<li>所有<code>address-size prefix</code></li>
<li>所有<code>operand-size prefix</code></li>
<li>所有<code>segment override prefix</code></li>
<li>所有<code>opcode</code>的第一个字节</li>
</ol><p>它们是两两不相交的. 这是必须的吗? 这背后反映了怎样的隐情?</p></div></div>
<p>另外我们在这里先给出<code>ModR/M</code>字节和<code>SIB</code>字节的格式,
它们是用来确定指令的操作数的, 详细的功能会在将来进行描述:</p>
<pre><code>ModR/M byte
7    6    5    4    3    2    1    0
+--------+-------------+-------------+
|  mod   | reg/opcode  |     r/m     |
+--------+-------------+-------------+


SIB (scale index base) byte
7    6    5    4    3    2    1    0
+--------+-------------+-------------+
|   ss   |    index    |    base     |
+--------+-------------+-------------+
</code></pre><p>事实上, 一个字节最多只能区分256种不同的指令形式.
当指令形式的数目大于256时, 我们需要使用另外的方法来识别它们.
x86中有主要有两种方法来解决这个问题:</p>
<ul>
<li>一种方法是使用转义码(escape code).
x86中有一个2字节转义码<code>0x0f</code>, 当指令<code>opcode</code>的第一个字节是<code>0x0f</code>时,
表示需要再读入一个字节才能决定具体的指令形式(部分条件跳转指令就属于这种情况).
后来随着各种SSE指令集的加入, 使用2字节转义码也不足以表示所有的指令形式了,
x86在2字节转义码的基础上又引入了3字节转义码,
当指令<code>opcode</code>的前两个字节是<code>0x0f</code>和<code>0x38</code>时,表示需要再读入一个字节才能决定具体的指令形式.</li>
<li>另一种方法是使用<code>ModR/M</code>字节中的扩展opcode域来对<code>opcode</code>的长度进行扩充.
有些时候, 读入一个字节也还不能完全确定具体的指令形式,
这时候需要读入紧跟在<code>opcode</code>后面的<code>ModR/M</code>字节,
把其中的<code>reg/opcode</code>域当做<code>opcode</code>的一部分来解释, 才能决定具体的指令形式.
x86把这些指令划分成不同的指令组(instruction group),
在同一个指令组中的指令需要通过<code>ModR/M</code>字节中的扩展opcode域来区分.</li>
</ul>
<h2 id="指令集细节">指令集细节</h2>
<p>要实现一条指令, 首先你需要知道这条指令的格式和功能, 格式决定如何解释, 功能决定如何执行.
而这些信息都在instruction set page中, 因此你务必知道如何阅读它们.
我们以<code>mov</code>指令的opcode表为例来说明如何阅读:</p>
<pre><code>     Opcode       Instruction       Clocks        Description

&lt; 1&gt; 88 /r        MOV r/m8,r8       2/2           Move byte register to r/m byte
&lt; 2&gt; 89 /r        MOV r/m16,r16     2/2           Move word register to r/m word
&lt; 3&gt; 89 /r        MOV r/m32,r32     2/2           Move dword register to r/m dword
&lt; 4&gt; 8A /r        MOV r8,r/m8       2/4           Move r/m byte to byte register
&lt; 5&gt; 8B /r        MOV r16,r/m16     2/4           Move r/m word to word register
&lt; 6&gt; 8B /r        MOV r32,r/m32     2/4           Move r/m dword to dword register
&lt; 7&gt; 8C /r        MOV r/m16,Sreg    2/2           Move segment register to r/m word
&lt; 8&gt; 8D /r        MOV Sreg,r/m16    2/5,pm=18/19  Move r/m word to segment register
&lt; 9&gt; A0           MOV AL,moffs8     4             Move byte at (seg:offset) to AL
&lt;10&gt; A1           MOV AX,moffs16    4             Move word at (seg:offset) to AX
&lt;11&gt; A1           MOV EAX,moffs32   4             Move dword at (seg:offset) to EAX
&lt;12&gt; A2           MOV moffs8,AL     2             Move AL to (seg:offset)
&lt;13&gt; A3           MOV moffs16,AX    2             Move AX to (seg:offset)
&lt;14&gt; A3           MOV moffs32,EAX   2             Move EAX to (seg:offset)
&lt;15&gt; B0 + rb ib   MOV r8,imm8       2             Move immediate byte to register
&lt;16&gt; B8 + rw iw   MOV r16,imm16     2             Move immediate word to register
&lt;17&gt; B8 + rd id   MOV r32,imm32     2             Move immediate dword to register
&lt;18&gt; C6 /0 ib (*) MOV r/m8,imm8     2/2           Move immediate byte to r/m byte
&lt;19&gt; C7 /0 iw (*) MOV r/m16,imm16   2/2           Move immediate word to r/m word
&lt;20&gt; C7 /0 id (*) MOV r/m32,imm32   2/2           Move immediate dword to r/m dword

---------------------------------------------------------------------------
NOTES:
moffs8, moffs16, and moffs32 all consist of a simple offset relative
to the segment base. The 8, 16, and 32 refer to the size of the data. The
address-size attribute of the instruction determines the size of the
offset, either 16 or 32 bits.
---------------------------------------------------------------------------

注:
标记了(*)的指令形式的Opcode相对于i386手册有改动, 具体情况见下文的描述.
</code></pre><p>上表中的每一行给出了<code>mov</code>指令的不同形式, 每一列分别表示这种形式的opcode,
汇编语言格式, 执行所需周期, 以及功能描述.
由于NEMU关注的是功能的模拟, 因此<code>Clocks</code>一列不必关心.
 <font color="red">另外需要注意的是, i386手册中的汇编语言格式都是Intel格式,
 而objdump的默认格式是AT&amp;T格式, 两者的源操作数和目的操作数位置不一样,
 千万不要把它们混淆了! 否则你将会陷入难以理解的bug中.</font></p>
<p>首先我们来看<code>mov</code>指令的第一种形式:</p>
<pre><code>     Opcode       Instruction       Clocks        Description
&lt; 1&gt; 88 /r        MOV r/m8,r8       2/2           Move byte register to r/m byte
</code></pre><ul>
<li>从功能描述可以看出, 它的作用是"将一个8位寄存器中的数据传送到8位的寄存器或者内存中",
其中<code>r/m</code>表示"寄存器或内存".</li>
<li>Opcode一列中的编码都是用十六进制表示, <code>88</code>表示这条指令的opcode的首字节是<code>0x88</code>,
<code>/r</code>表示后面跟一个<code>ModR/M</code>字节, 并且<code>ModR/M</code>字节中的<code>reg/opcode</code>域解释成通用寄存器的编码,
用来表示其中一个操作数.</li>
<li>通用寄存器的编码如下:</li>
</ul>
<table>
<thead>
<tr>
<th>二进制编码</th>
<th>000</th>
<th>001</th>
<th>010</th>
<th>011</th>
<th>100</th>
<th>101</th>
<th>110</th>
<th>111</th>
</tr>
</thead>
<tbody>
<tr>
<td>8位寄存器</td>
<td>AL</td>
<td>CL</td>
<td>DL</td>
<td>BL</td>
<td>AH</td>
<td>CH</td>
<td>DH</td>
<td>BH</td>
</tr>
<tr>
<td>16位寄存器</td>
<td>AX</td>
<td>CX</td>
<td>DX</td>
<td>BX</td>
<td>SP</td>
<td>BP</td>
<td>SI</td>
<td>DI</td>
</tr>
<tr>
<td>32位寄存器</td>
<td>EAX</td>
<td>ECX</td>
<td>EDX</td>
<td>EBX</td>
<td>ESP</td>
<td>EBP</td>
<td>ESI</td>
<td>EDI</td>
</tr>
</tbody>
</table>
<ul>
<li>Instruction一列中, <code>r/m8</code>表示操作数是8位的寄存器或内存,
<code>r8</code>表示操作数是8位寄存器, 按照Intel格式的汇编语法来解释,
表示将8位寄存器(<code>r8</code>)中的数据传送到8位寄存器或内存(<code>r/m8</code>)中, 这和功能描述是一致的.
至于<code>r/m</code>表示的究竟是寄存器还是内存, 这是由<code>ModR/M</code>字节的<code>mod</code>域决定的:
当<code>mod</code>域取值为<code>3</code>的时候, <code>r/m</code>表示的是寄存器;
否则<code>r/m</code>表示的是内存. 表示内存的时候又有多种寻址方式, 具体信息参考i386手册中的表格17-3.</li>
</ul>
<p>看明白了上面的第一种形式之后, 接下来的两种形式也就不难看懂了:</p>
<pre><code>&lt; 2&gt; 89 /r        MOV r/m16,r16     2/2           Move word register to r/m word
&lt; 3&gt; 89 /r        MOV r/m32,r32     2/2           Move dword register to r/m dword
</code></pre><p>但你会发现, 这两种形式的<code>Opcode</code>都是一样的, 难道不会出现歧义吗?
不用着急, 还记得指令一般格式中的<code>operand-size prefix</code>吗? x86正是通过它来区分上面这两种形式的.
<code>operand-size prefix</code>的编码是<code>0x66</code>, 作用是指示当前指令需要改变操作数的宽度.
在i386中, 通常来说, 如果这个前缀没有出现, 操作数宽度默认是32位;
当这个前缀出现的时候, 操作数宽度就要改变成16位
(也有相反的情况, 这个前缀的出现使得操作数宽度从16位变成32位, 但这种情况在i386中极少出现).
换句话说, 如果把一个开头为<code>89 ...</code>的比特串解释成指令, 它就应该被解释成<code>MOV r/m32,r32</code>的形式;
如果比特串的开头是<code>66 89...</code>, 它就应该被解释成<code>MOV r/m16,r16</code>.</p>
<div class="panel panel-info"><div class="panel-heading"><h5 class="panel-title" id="操作数宽度前缀的由来"><i class="fa fa-comment-o"></i> 操作数宽度前缀的由来</h5></div><div class="panel-body"><p>i386是从<a href="http://en.wikipedia.org/wiki/Intel_8086" target="_blank">8086</a>发展过来的.
8086是一个16位的时代, 很多指令的16位版本在当时就已经实现好了.
要踏进32位的新时代, 兼容就成了需要仔细考量的一个重要因素.</p><p>一种最直接的方法是让32位的指令使用新的操作码, 但这样1字节的操作码很快就会用光.
假设8086已经实现了200条16位版本的指令形式, 为了加入这些指令形式的32位版本,
这种做法需要使用另外200个新的操作码, 使得大部分指令形式的操作码需要使用两个字节来表示,
这样直接导致了32位的程序代码会变长.
现在你可能会觉得每条指令的长度增加一个字节也没什么大不了,
但在i386诞生的那个遥远的时代(你可以在i386手册的封面看到那个时代),
内存是一种十分珍贵的资源, 因此这种使用新操作码的方法并不是一种明智的选择.</p><p>Intel想到的解决办法就是引入操作数宽度前缀, 来达到操作码复用的效果.
当处理器工作在16位模式(<a href="http://en.wikipedia.org/wiki/Real_mode" target="_blank">实模式</a>)下的时候, 默认执行16位版本的指令;
当处理器工作在32位模式(<a href="http://en.wikipedia.org/wiki/Protected_mode" target="_blank">保护模式</a>)下的时候, 默认执行32位版本的指令.
当某些需要的时候, 才通过操作数宽度前缀来指示操作数的宽度.
这种方法最大的好处就是不需要引入额外的操作码, 从而也不会明显地使得程序代码变长.
虽然在NEMU里面可以使用很简单的方法来模拟这个功能,
但在真实的芯片设计过程中, CPU的译码部件需要增加很多逻辑才能实现.</p></div></div>
<p>到现在为止, &lt;4&gt;-&lt;6&gt;三种形式你也明白了:6&gt;4&gt;</p>
<pre><code>&lt; 4&gt; 8A /r        MOV r8,r/m8       2/4           Move r/m byte to byte register
&lt; 5&gt; 8B /r        MOV r16,r/m16     2/4           Move r/m word to word register
&lt; 6&gt; 8B /r        MOV r32,r/m32     2/4           Move r/m dword to dword register
</code></pre><p><code>&lt;7&gt;</code> 和 <code>&lt;8&gt;</code> 两种形式的mov指令涉及到段寄存器:</p>
<pre><code>&lt; 7&gt; 8C /r        MOV r/m16,Sreg    2/2           Move segment register to r/m word
&lt; 8&gt; 8D /r        MOV Sreg,r/m16    2/5,pm=18/19  Move r/m word to segment register
</code></pre><p>PA中的x86去掉了段寄存器的实现, 我们可以忽略这两种形式的<code>mov</code>指令.</p>
<p><code>&lt;9&gt;</code> - <code>&lt;14&gt;</code> 这6种形式涉及到一种新的操作数记号<code>moffs</code>:</p>
<pre><code>&lt; 9&gt; A0           MOV AL,moffs8     4             Move byte at (seg:offset) to AL
&lt;10&gt; A1           MOV AX,moffs16    4             Move word at (seg:offset) to AX
&lt;11&gt; A1           MOV EAX,moffs32   4             Move dword at (seg:offset) to EAX
&lt;12&gt; A2           MOV moffs8,AL     2             Move AL to (seg:offset)
&lt;13&gt; A3           MOV moffs16,AX    2             Move AX to (seg:offset)
&lt;14&gt; A3           MOV moffs32,EAX   2             Move EAX to (seg:offset)
---------------------------------------------------------------------------
NOTES:
moffs8, moffs16, and moffs32 all consist of a simple offset relative
to the segment base. The 8, 16, and 32 refer to the size of the data. The
address-size attribute of the instruction determines the size of the
offset, either 16 or 32 bits.
---------------------------------------------------------------------------
</code></pre><p>NOTES中给出了<code>moffs</code>的含义, 它用来表示段内偏移量,
但PA中的x86没有"段"的概念, 目前可以理解成"相对于物理地址0处的偏移量".
这6种形式是<code>mov</code>指令的特殊形式, 它们可以不通过<code>ModR/M</code>字节,
让<code>displacement</code>直接跟在<code>opcode</code>后面, 同时让<code>displacement</code>来指示一个内存地址.</p>
<p><code>&lt;15&gt;</code> - <code>&lt;17&gt;</code> 三种形式涉及到两种新的操作数记号:</p>
<pre><code>&lt;15&gt; B0 + rb ib   MOV r8,imm8       2             Move immediate byte to register
&lt;16&gt; B8 + rw iw   MOV r16,imm16     2             Move immediate word to register
&lt;17&gt; B8 + rd id   MOV r32,imm32     2             Move immediate dword to register
</code></pre><p>其中:</p>
<ul>
<li><code>+rb</code>, <code>+rw</code>, <code>+rd</code>分别表示8位, 16位, 32位通用寄存器的编码.
和<code>ModR/M</code>中的<code>reg</code>域不一样的是, 这三种记号表示直接将通用寄存器的编号按数值加到<code>opcode</code>中
(也可以看成通用寄存器的编码嵌在<code>opcode</code>的低三位),
因此识别指令的时候可以通过<code>opcode</code>的低三位确定一个寄存器操作数.</li>
<li><code>ib</code>, <code>iw</code>, <code>id</code>分别表示8位, 16位, 32位立即数</li>
</ul>
<p>最后3种形式涉及到一种新的操作码记号<code>/digit</code>, 其中<code>digit</code>为<code>0</code>~<code>7</code>中的一个数字:</p>
<pre><code>&lt;18&gt; C6 /0 ib (*) MOV r/m8,imm8     2/2           Move immediate byte to r/m byte
&lt;19&gt; C7 /0 iw (*) MOV r/m16,imm16   2/2           Move immediate word to r/m word
&lt;20&gt; C7 /0 id (*) MOV r/m32,imm32   2/2           Move immediate dword to r/m dword

注:
标记了(*)的指令形式的Opcode相对于i386手册有改动, 具体情况见下文的描述.
</code></pre><p>上述形式中的<code>/0</code>表示一个<code>ModR/M</code>字节,
并且<code>ModR/M</code>字节中的<code>reg/opcode</code>域解释成扩展opcode, 其值取<code>0</code>.
对于含有<code>/digit</code>记号的指令形式, 需要通过指令本身的<code>opcode</code>和<code>ModR/M</code>中的扩展opcode共同决定指令的形式,
例如<code>80 /0</code>表示<code>add</code>指令的一种形式, 而<code>80 /5</code>则表示<code>sub</code>指令的一种形式,
只看<code>opcode</code>的首字节<code>80</code>不能区分它们.</p>
<p>注: 在i386手册中, 这3种形式的<code>mov</code>指令并没有<code>/0</code>的记号,
在这里加入<code>/0</code>纯粹是为了说明<code>/digit</code>记号的意思.
但同时这条指令在i386中也比较特殊, 它需要使用<code>ModR/M</code>字节来表示一个寄存器或内存的操作数,
但<code>ModR/M</code>字节中的<code>reg/opcode</code>域却没有用到
(一般情况下, <code>ModR/M</code>字节中的<code>reg/opcode</code>域要么表示一个寄存器操作数, 要么作为扩展opcode),
i386手册也没有对此进行特别的说明, 直觉上的解释就是"无论<code>ModR/M</code>字节中的<code>reg/opcode</code>域是什么值,
都可以被CPU识别成这种形式的<code>mov</code>指令".
x86是商业CPU, 我们无法从电路级实现来考证这一解释,
但对编译器生成代码来说, 这条指令中的<code>reg/opcode</code>域总得有个确定的值,
因此编译器一般会把这个值设成<code>0</code>.
在NEMU的框架代码中, 对这3种形式的<code>mov</code>指令的实现和i386手册中给出<code>Opcode</code>保持一致,
忽略<code>ModR/M</code>字节中的<code>reg/opcode</code>域, 没有判断其值是否为<code>0</code>.
如果你不能理解这段话在说什么, 你可以忽略它, 因为这并不会影响实验的进行.</p>
<p>到此为止, 你已经学会了如何阅读大部分的指令集细节了.
需要说明的是, 这里举的<code>mov</code>指令的例子并没有完全覆盖i386手册中指令集细节的所有记号, 若有疑问, 请参考i386手册.</p>
<p>除了opcode表之外, <code>Operation</code>, <code>Description</code>和<code>Flags Affected</code>这三个条目都要仔细阅读,
这样你才能完整地掌握一条指令的功能.
<code>Exceptions</code>条目涉及到执行这条指令可能产生的异常,
由于PA中的x86不打算加入异常处理的机制, 你可以不用关心这一条目.</p>
<footer class="page-footer-ex"> <span class="page-footer-ex-copyright"> By <a href="https://sashimi-yzh.github.io/" target="_blank">Zihao Yu</a>, 采用<a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank">知识共享 署名-非商业性使用-相同方式共享 3.0 中国大陆 许可协议</a>发布 </span>            <span class="page-footer-ex-footer-update"> 此页面修订于:  2023-02-25 08:25:35 </span> </footer>
</section>
</div>
<div class="search-results">
<div class="has-results">
<h1 class="search-results-title"><span class="search-results-count"></span> results matching "<span class="search-query"></span>"</h1>
<ul class="search-results-list"></ul>
</div>
<div class="no-results">
<h1 class="search-results-title">No results matching "<span class="search-query"></span>"</h1>
</div>
</div>
</div>
</div>
</div>
</div>
<a aria-label="Previous page: 更新日志" class="navigation navigation-prev navigation-unique" href="changelog.html">
<i class="fa fa-angle-left"></i>
</a>
</div>
<script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"i386手册指令集阅读指南","level":"1.7.8","depth":2,"previous":{"title":"更新日志","level":"1.7.7","depth":2,"path":"changelog.md","ref":"changelog.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"3.x.x","theme":"default","variables":{},"plugins":["theme-comscore","intopic-toc","localized-footer","page-footer-ex","callouts"],"pluginsConfig":{"callouts":{"option":{"alert":"info","picto":"fa-edit"},"flag":{"alert":"success","picto":"fa-flag"},"question":{"alert":"info","picto":"fa-question-circle"},"info":{"alert":"info","picto":"fa-info-circle"},"todo":{"alert":"warning","picto":"fa-edit"},"caution":{"alert":"danger","picto":"fa-bullhorn"},"danger":{"alert":"danger","picto":"fa-exclamation"},"showTypeInHeader":false},"intopic-toc":{"isCollapsed":false,"isScrollspyActive":true,"label":"导航","maxDepth":6,"mode":"nested","selector":".markdown-section h2, .markdown-section h3, .markdown-section h4","visible":true},"page-footer-ex":{"copyright":"By [Zihao Yu](https://sashimi-yzh.github.io/), 采用[知识共享 署名-非商业性使用-相同方式共享 3.0 中国大陆 许可协议](http://creativecommons.org/licenses/by-nc-sa/3.0/cn/)发布","markdown":true,"update_format":"YYYY-MM-DD HH:mm:ss","update_label":"此页面修订于: "},"search":{},"localized-footer":{"filename":"FOOTER.md","hline":"true"},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"theme":"white","family":"sans","size":2},"highlight":{},"theme-comscore":{},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles.css","pdf":"styles.css"}},"file":{"path":"i386-intro.md","mtime":"2023-02-25T00:25:35.603Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2023-12-05T03:26:43.464Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>
{% endblock %}