{% extends 'base.html' %}
{% block head %}
<title>Linux入门教程 · GitBook</title>
<link href="man.html" rel="next"/>
<link href="why.html" rel="prev"/>
{% endblock %}
{% block body %}
<div class="book">
<div class="book-summary">
<div id="book-search-input" role="search">
<input placeholder="Type to search" type="text"/>
</div>
<nav role="navigation">
<ul class="summary">
<li class="chapter" data-level="1.1" data-path="index.html">
<a href="index.html">
            
                    
                    Introduction
            
                </a>
</li>
<li class="chapter" data-level="1.2" data-path="PA0.html">
<a href="PA0.html">
            
                    
                    PA0 - 世界诞生的前夜: 开发环境配置
            
                </a>
<ul class="articles">
<li class="chapter" data-level="1.2.1" data-path="0.1.html">
<a href="0.1.html">
            
                    
                    Installing GNU/Linux
            
                </a>
</li>
<li class="chapter" data-level="1.2.2" data-path="0.2.html">
<a href="0.2.html">
            
                    
                    First Exploration with GNU/Linux
            
                </a>
</li>
<li class="chapter" data-level="1.2.3" data-path="0.3.html">
<a href="0.3.html">
            
                    
                    Installing Tools
            
                </a>
</li>
<li class="chapter" data-level="1.2.4" data-path="0.4.html">
<a href="0.4.html">
            
                    
                    Configuring vim
            
                </a>
</li>
<li class="chapter" data-level="1.2.5" data-path="0.5.html">
<a href="0.5.html">
            
                    
                    More Exploration
            
                </a>
</li>
<li class="chapter" data-level="1.2.6" data-path="0.6.html">
<a href="0.6.html">
            
                    
                    Getting Source Code for PAs
            
                </a>
</li>
</ul>
</li>
<li class="chapter" data-level="1.3" data-path="PA1.html">
<a href="PA1.html">
            
                    
                    PA1 - 开天辟地的篇章: 最简单的计算机
            
                </a>
<ul class="articles">
<li class="chapter" data-level="1.3.1" data-path="1.1.html">
<a href="1.1.html">
            
                    
                    在开始愉快的PA之旅之前
            
                </a>
</li>
<li class="chapter" data-level="1.3.2" data-path="1.2.html">
<a href="1.2.html">
            
                    
                    开天辟地的篇章
            
                </a>
</li>
<li class="chapter" data-level="1.3.3" data-path="1.3.html">
<a href="1.3.html">
            
                    
                    RTFSC
            
                </a>
</li>
<li class="chapter" data-level="1.3.4" data-path="1.4.html">
<a href="1.4.html">
            
                    
                    基础设施
            
                </a>
</li>
<li class="chapter" data-level="1.3.5" data-path="1.5.html">
<a href="1.5.html">
            
                    
                    表达式求值
            
                </a>
</li>
<li class="chapter" data-level="1.3.6" data-path="1.6.html">
<a href="1.6.html">
            
                    
                    监视点
            
                </a>
</li>
<li class="chapter" data-level="1.3.7" data-path="1.7.html">
<a href="1.7.html">
            
                    
                    如何阅读手册
            
                </a>
</li>
</ul>
</li>
<li class="chapter" data-level="1.4" data-path="PA2.html">
<a href="PA2.html">
            
                    
                    PA2 - 简单复杂的机器: 冯诺依曼计算机系统
            
                </a>
<ul class="articles">
<li class="chapter" data-level="1.4.1" data-path="2.1.html">
<a href="2.1.html">
            
                    
                    不停计算的机器
            
                </a>
</li>
<li class="chapter" data-level="1.4.2" data-path="2.2.html">
<a href="2.2.html">
            
                    
                    RTFSC(2)
            
                </a>
</li>
<li class="chapter" data-level="1.4.3" data-path="2.3.html">
<a href="2.3.html">
            
                    
                    程序, 运行时环境与AM
            
                </a>
</li>
<li class="chapter" data-level="1.4.4" data-path="2.4.html">
<a href="2.4.html">
            
                    
                    基础设施(2)
            
                </a>
</li>
<li class="chapter" data-level="1.4.5" data-path="2.5.html">
<a href="2.5.html">
            
                    
                    输入输出
            
                </a>
</li>
</ul>
</li>
<li class="chapter" data-level="1.5" data-path="PA3.html">
<a href="PA3.html">
            
                    
                    PA3 - 穿越时空的旅程: 批处理系统
            
                </a>
<ul class="articles">
<li class="chapter" data-level="1.5.1" data-path="3.1.html">
<a href="3.1.html">
            
                    
                    最简单的操作系统
            
                </a>
</li>
<li class="chapter" data-level="1.5.2" data-path="3.2.html">
<a href="3.2.html">
            
                    
                    穿越时空的旅程
            
                </a>
</li>
<li class="chapter" data-level="1.5.3" data-path="3.3.html">
<a href="3.3.html">
            
                    
                    用户程序和系统调用
            
                </a>
</li>
<li class="chapter" data-level="1.5.4" data-path="3.4.html">
<a href="3.4.html">
            
                    
                    文件系统
            
                </a>
</li>
<li class="chapter" data-level="1.5.5" data-path="3.5.html">
<a href="3.5.html">
            
                    
                    精彩纷呈的应用程序
            
                </a>
</li>
</ul>
</li>
<li class="chapter" data-level="1.6" data-path="PA4.html">
<a href="PA4.html">
            
                    
                    PA4 - 虚实交错的魔法: 分时多任务
            
                </a>
<ul class="articles">
<li class="chapter" data-level="1.6.1" data-path="4.1.html">
<a href="4.1.html">
            
                    
                    多道程序
            
                </a>
</li>
<li class="chapter" data-level="1.6.2" data-path="4.2.html">
<a href="4.2.html">
            
                    
                    虚实交错的魔法
            
                </a>
</li>
<li class="chapter" data-level="1.6.3" data-path="4.3.html">
<a href="4.3.html">
            
                    
                    超越容量的界限
            
                </a>
</li>
<li class="chapter" data-level="1.6.4" data-path="4.4.html">
<a href="4.4.html">
            
                    
                    来自外部的声音
            
                </a>
</li>
<li class="chapter" data-level="1.6.5" data-path="4.5.html">
<a href="4.5.html">
            
                    
                    编写不朽的传奇
            
                </a>
</li>
</ul>
</li>
<li class="chapter" data-level="1.7" data-path="blank.html">
<a href="blank.html">
            
                    
                    杂项
            
                </a>
<ul class="articles">
<li class="chapter" data-level="1.7.1" data-path="FAQ.html">
<a href="FAQ.html">
            
                    
                    常见问题(FAQ)
            
                </a>
</li>
<li class="chapter" data-level="1.7.2" data-path="why.html">
<a href="why.html">
            
                    
                    为什么要学习计算机系统基础
            
                </a>
</li>
<li class="chapter active" data-level="1.7.3" data-path="linux.html">
<a href="linux.html">
            
                    
                    Linux入门教程
            
                </a>
</li>
<li class="chapter" data-level="1.7.4" data-path="man.html">
<a href="man.html">
            
                    
                    man入门教程
            
                </a>
</li>
<li class="chapter" data-level="1.7.5" data-path="git.html">
<a href="git.html">
            
                    
                    git入门教程
            
                </a>
</li>
<li class="chapter" data-level="1.7.6" data-path="nemu-isa-api.html">
<a href="nemu-isa-api.html">
            
                    
                    NEMU ISA相关API说明文档
            
                </a>
</li>
<li class="chapter" data-level="1.7.7" data-path="changelog.html">
<a href="changelog.html">
            
                    
                    更新日志
            
                </a>
</li>
<li class="chapter" data-level="1.7.8" data-path="i386-intro.html">
<a href="i386-intro.html">
            
                    
                    i386手册指令集阅读指南
            
                </a>
</li>
</ul>
</li>
<li class="divider"></li>
<li>
<a class="gitbook-link" href="https://www.gitbook.com" target="blank">
            Published with GitBook
        </a>
</li>
</ul>
</nav>
</div>
<div class="book-body">
<div class="body-inner">
<div class="book-header" role="navigation">
<!-- Title -->
<h1>
<i class="fa fa-circle-o-notch fa-spin"></i>
<a href=".">Linux入门教程</a>
</h1>
</div>
<div class="page-wrapper" role="main" tabindex="-1">
<div class="page-inner">
<div id="book-search-results">
<div class="search-noresults">
<section class="normal markdown-section">
<h1 id="linux入门教程">Linux入门教程</h1>
<p>以下内容引用自jyy的操作系统实验课程网站, 并有少量修改和补充.
如果你是第一次使用Linux, 请你一边仔细阅读教程, 一边尝试运行教程中提到的命令.</p>
<h2 id="探索命令行">探索命令行</h2>
<p>Linux命令行中的命令使用格式都是相同的:</p>
<pre><code>命令名称 参数1 参数2 参数3 ...
</code></pre><p>参数之间用任意数量的空白字符分开.
关于命令行, 可以先阅读<a href="https://linux.cn/article-6160-1.html" target="_blank">一些基本常识</a>.
然后我们介绍最常用的一些命令:</p>
<ul>
<li><code>ls</code>用于列出当前目录(即"文件夹")下的所有文件(或目录).
目录会用蓝色显示. <code>ls -l</code>可以显示详细信息.</li>
<li><code>pwd</code>能够列出当前所在的目录.</li>
<li><code>cd DIR</code>可以切换到<code>DIR</code>目录.
在Linux中, 每个目录中都至少包含两个目录: <code>.</code>指向该目录自身, <code>..</code>指向它的上级目录. 文件系统的根是<code>/</code>.</li>
<li><code>touch NEWFILE</code>可以创建一个内容为空的新文件<code>NEWFILE</code>, 若<code>NEWFILE</code>已存在, 其内容不会丢失.</li>
<li><code>cp SOURCE DEST</code>可以将<code>SOURCE</code>文件复制为<code>DEST</code>文件; 如果<code>DEST</code>是一个目录, 则将<code>SOURCE</code>文件复制到该目录下.</li>
<li><code>mv SOURCE DEST</code>可以将<code>SOURCE</code>文件重命名为<code>DEST</code>文件; 如果<code>DEST</code>是一个目录, 则将<code>SOURCE</code>文件移动到该目录下.</li>
<li><code>mkdir DIR</code>能够创建一个<code>DIR</code>目录.</li>
<li><code>rm FILE</code>能够删除<code>FILE</code>文件; 如果使用<code>-r</code>选项则可以递归删除一个目录.
删除后的文件无法恢复, 使用时请谨慎!</li>
<li><code>man</code>可以查看命令的帮助.
例如<code>man ls</code>可以查看<code>ls</code>命令的使用方法.
灵活应用<code>man</code>和互联网搜索, 可以快速学习新的命令.</li>
</ul>
<p><code>man</code>的功能不仅限于此.
<code>man</code>后可以跟两个参数, 可以查看不同类型的帮助(请在互联网上搜索).
例如当你不知道C标准库函数<code>freopen</code>如何使用时, 可以键入命令</p>
<pre><code>man 3 freopen
</code></pre><div class="panel panel-danger"><div class="panel-heading"><h5 class="panel-title" id="学会使用man"><i class="fa fa-bullhorn"></i> 学会使用man</h5></div><div class="panel-body"><p>如果你是第一次使用<code>man</code>, 请阅读<a href="man.html">这里</a>.
这个教程除了说明如何使用<code>man</code>之外, 还会教你在使用一款新的命令行工具时如何获得帮助.</p></div></div>
<!-- -->
<div class="panel panel-info"><div class="panel-heading"><h5 class="panel-title" id="消失的cd"><i class="fa fa-question-circle"></i> 消失的cd</h5></div><div class="panel-body"><p>上述各个命令除了<code>cd</code>之外都能找到它们的manpage, 这是为什么?
如果你思考后仍然感到困惑, 试着到互联网上寻找答案.</p></div></div>
<p>下面给出一些常用命令使用的例子, 你可以键入每条命令之后使用<code>ls</code>查看命令执行的结果:</p>
<pre><code>$ mkdir temp      # 创建一个目录temp
$ cd temp         # 切换到目录temp
$ touch newfile   # 创建一个空文件newfile
$ mkdir newdir    # 创建一个目录newdir
$ cd newdir       # 切换到目录newdir
$ cp ../newfile . # 将上级目录中的文件newfile复制到当前目录下
$ cp newfile aaa  # 将文件newfile复制为新文件aaa
$ mv aaa bbb      # 将文件aaa重命名为bbb
$ mv bbb ..       # 将文件bbb移动到上级目录
$ cd ..           # 切换到上级目录
$ rm bbb          # 删除文件bbb
$ cd ..           # 切换到上级目录
$ rm -r temp      # 递归删除目录temp
</code></pre><div class="panel panel-success"><div class="panel-heading"><h5 class="panel-title" id="更多的命令行知识"><i class="fa fa-lightbulb-o"></i> 更多的命令行知识</h5></div><div class="panel-body"><p>仅仅了解这些最基础的命令行知识是不够的.
通常, 我们可以抱着如下的信条: 只要我们能想到的, 就一定有方便的办法能够办到.
因此当你想要完成某件事却又不知道应该做什么的时候, 请向Google求助.
如果你想以Linux作为未来的事业, 那就可以去图书馆或互联网上找一些相关的书籍来阅读.</p></div></div>
<h2 id="统计代码行数">统计代码行数</h2>
<p>第一个例子是统计一个目录中(包含子目录)中的代码行数.
如果想知道当前目录下究竟有多少行的代码, 就可以在命令行中键入如下命令:</p>
<pre><code>find . | grep '\.c$\|\.h$' | xargs wc -l
</code></pre><p>如果用<code>man find</code>查看<code>find</code>操作的功能, 可以看到<code>find</code>是搜索目录中的文件.
Linux中一个点<code>.</code>始终表示Shell当前所在的目录, 因此<code>find .</code>实际能够列出当前目录下的所有文件.
如果在文件很多的地方键入<code>find .</code>, 将会看到过多的文件, 此时可以按<code>CTRL + c</code>退出.</p>
<p>同样, 用<code>man</code>查看<code>grep</code>的功能——"print lines matching a pattern".
<code>grep</code>实现了输入的过滤, 我们的<code>grep</code>有一个参数, 它能够匹配以<code>.c</code>或<code>.h</code>结束的文件.
正则表达式是处理字符串非常强大的工具之一, 每一个程序员都应该掌握其相关的知识.
有兴趣的同学可以首先阅读一个<a href="https://linux.vbird.org/linux_basic/centos7/0330regularex.php" target="_blank">基础的教程</a>,
然后看一个有趣的小例子: <a href="http://coolshell.cn/articles/2704.html" target="_blank">如何用正则表达式判定素数</a>.
正则表达式还可以用来编写一个30行的java表达式求值程序(传统方法几乎不可能), 聪明的你能想到是怎么完成的吗?
上述的<code>grep</code>命令能够提取所有<code>.c</code>和<code>.h</code>结尾的文件.</p>
<p>刚才的<code>find</code>和<code>grep</code>命令, 都从标准输入中读取数据, 并输出到标准输出.
关于什么是标准输入输出, 请参考<a href="http://en.wikipedia.org/wiki/Standard_streams" target="_blank">这里</a>.
连接起这两个命令的关键就是管道符号<code>|</code>.
这一符号的左右都是Shell命令, <code>A | B</code>的含义是创建两个进程<code>A</code>和<code>B</code>, 并将<code>A</code>进程的标准输出连接到<code>B</code>进程的标准输入.
这样, 将<code>find</code>和<code>grep</code>连接起来就能够筛选出当前目录(<code>.</code>)下所有以<code>.c</code>或<code>.h</code>结尾的文件.</p>
<p>我们最后的任务是统计这些文件所占用的总行数, 此时可以用<code>man</code>查看<code>wc</code>命令.
<code>wc</code>命令的<code>-l</code>选项能够计算代码的行数.
<code>xargs</code>命令十分特殊, 它能够将标准输入转换为参数, 传送给第一个参数所指定的程序.
所以, 代码中的<code>xargs wc -l</code>就等价于执行<code>wc -l aaa.c bbb.c include/ccc.h ...</code>, 最终完成代码行数统计.</p>
<h2 id="统计磁盘使用情况">统计磁盘使用情况</h2>
<p>以下命令统计<code>/usr/share</code>目录下各个目录所占用的磁盘空间:</p>
<pre><code>du -sc /usr/share/* | sort -nr
</code></pre><p><code>du</code>是磁盘空间分析工具, <code>du -sc</code>将目录的大小顺次输出到标准输出, 继而通过管道传送给<code>sort</code>.
<code>sort</code>是数据排序工具, 其中的选项<code>-n</code>表示按照数值进行排序, 而<code>-r</code>则表示从大到小输出.
<code>sort</code>可以将这些参数连写在一起.</p>
<p>然而我们发现, <code>/usr/share</code>中的目录过多, 无法在一个屏幕内显示.
此时, 我们可以再使用一个命令: <code>more</code>或<code>less</code>.</p>
<pre><code>du -sc /usr/share/* | sort -nr | more
</code></pre><p>此时将会看到输出的前几行结果.
<code>more</code>工具使用空格翻页, 并可以用<code>q</code>键在中途退出.
<code>less</code>工具则更为强大, 不仅可以向下翻页, 还可以向上翻页, 同样使用<code>q</code>键退出.
这里还有一个<a href="http://en.wikipedia.org/wiki/Less_(Unix)" target="_blank">关于less的小故事</a>.</p>
<h2 id="在linux下编写hello-world程序">在Linux下编写Hello World程序</h2>
<p>Linux中用户的主目录是<code>/home/用户名称</code>, 如果你的用户名是<code>user</code>, 你的主目录就是<code>/home/user</code>.
用户的<code>home</code>目录可以用波浪符号<code>~</code>替代, 例如临时文件目录<code>/home/user/Templates</code>可以简写为<code>~/Templates</code>.
现在我们就可以进入主目录并编辑文件了.
如果<code>Templates</code>目录不存在, 可以通过<code>mkdir</code>命令创建它:</p>
<pre><code>cd ~
mkdir Templates
</code></pre><p>创建成功后, 键入</p>
<pre><code>cd Templates
</code></pre><p>可以完成目录的切换.
注意在输入目录名时, <code>tab</code>键可以提供联想.</p>
<div class="panel panel-success"><div class="panel-heading"><h5 class="panel-title" id="你感到键入困难吗"><i class="fa fa-lightbulb-o"></i> 你感到键入困难吗?</h5></div><div class="panel-body"><p>你可能会经常要在终端里输入类似于</p><pre><code>cd AVeryVeryLongFileName
</code></pre><p>的命令, 你一定觉得非常烦躁.
回顾上面所说的原则之一: 如果你感到有什么地方不对, 就一定有什么好办法来解决.
试试<code>tab</code>键吧.</p><p>Shell中有很多这样的小技巧, 你也可以使用其他的Shell例如zsh, 提供更丰富好用的功能. 总之, 尝试和改变是最重要的.</p></div></div>
<p>进入正确的目录后就可以编辑文件了, 开源世界中主流的两大编辑器是<code>vi(m)</code>和<code>emacs</code>, 你可以使用其中的任何一种.
如果你打算使用<code>emacs</code>, 你还需要安装它</p>
<pre><code>apt-get install emacs
</code></pre><p><code>vi</code>和<code>emacs</code>这两款编辑器都需要一定的时间才能上手,
它们共同的特点是需要花较多的时间才能适应基本操作方式(命令或快捷键),
但一旦熟练运用, 编辑效率就比传统的编辑器快很多.</p>
<p>进入了正确的目录后, 输入相应的命令就能够开始编辑文件.
例如输入</p>
<pre><code>vi hello.c
或emacs hello.c
</code></pre><p>就能开启一个文件编辑.
例如可以键入如下代码(对于首次使用<code>vi</code>或<code>emacs</code>的同学, 键入代码可能会花去一些时间,
在编辑的同时要大量查看网络上的资料):</p>
<pre><code class="lang-c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Hello, Linux World!\n"</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>保存后就能够看到<code>hello.c</code>的内容了.
终端中可以用<code>cat hello.c</code>查看代码的内容.
如果要将它编译, 可以使用<code>gcc</code>命令:</p>
<pre><code>gcc hello.c -o hello
</code></pre><p><code>gcc</code>的<code>-o</code>选项指定了输出文件的名称, 如果将<code>-o hello</code>改为<code>-o hi</code>, 将会生成名为<code>hi</code>的可执行文件.
如果不使用<code>-o</code>选项, 则会默认生成名为<code>a.out</code>的文件,
它的含义是<a href="http://en.wikipedia.org/wiki/A.out" target="_blank">assembler output</a>. 在命令行输入</p>
<pre><code>./hello
</code></pre><p>就能够运行改程序.
命令中的<code>./</code>是不能少的, 点代表了当前目录, 而<code>./hello</code>则表示当前目录下的<code>hello</code>文件.
与Windows不同, Linux系统默认情况下并不查找当前目录,
这是因为Linux下有大量的标准工具(如<code>test</code>等), 很容易与用户自己编写的程序重名, 不搜索当前目录消除了命令访问的歧义.</p>
<h2 id="使用重定向">使用重定向</h2>
<p>有时我们希望将程序的输出信息保存到文件中, 方便以后查看.
例如你编译了一个程序<code>myprog</code>, 你可以使用以下命令对<code>myprog</code>进行反汇编, 并将反汇编的结果保存到<code>output</code>文件中:</p>
<pre><code>objdump -d myprog &gt; output
</code></pre><p><code>&gt;</code>是标准输出重定向符号, 可以将前一命令的输出重定向到文件<code>output</code>中.
这样, 你就可以使用文本编辑工具查看<code>output</code>了.</p>
<p>但你会发现, 使用了输出重定向之后, 屏幕上就不会显示<code>myprog</code>输出的任何信息.
如果你希望输出到文件的同时也输出到屏幕上, 你可以使用<code>tee</code>命令:</p>
<pre><code>objdump -d myprog | tee output
</code></pre><p>使用输出重定向还能很方便地实现一些常用的功能, 例如</p>
<pre><code>&gt; empty                  # 创建一个名为empty的空文件
cat old_file &gt; new_file  # 将文件old_file复制一份, 新文件名为new_file
</code></pre><p>如果<code>myprog</code>需要从键盘上读入大量数据(例如一个图的拓扑结构),
当你需要反复对<code>myprog</code>进行测试的时候, 你需要多次键入大量相同的数据.
为了避免这种无意义的重复键入, 你可以使用以下命令:</p>
<pre><code>./myprog &lt; data
</code></pre><p><code>&lt;</code>是标准输入重定向符号, 可以将前一命令的输入重定向到文件<code>data</code>中.
这样, 你只需要将<code>myprog</code>读入的数据一次性输入到文件<code>data</code>中,
<code>myprog</code>就会从文件<code>data</code>中读入数据, 节省了大量的时间.</p>
<p>下面给出了一个综合使用重定向的例子:</p>
<pre><code>time ./myprog &lt; data | tee output
</code></pre><p>这个命令在运行<code>myprog</code>的同时, 指定其从文件<code>data</code>中读入数据, 并将其输出信息打印到屏幕和文件<code>output</code>中.
<code>time</code>工具记录了这一过程所消耗的时间, 最后你会在屏幕上看到<code>myprog</code>运行所需要的时间.
如果你只关心<code>myprog</code>的运行时间, 你可以使用以下命令将<code>myprog</code>的输出过滤掉:</p>
<pre><code>time ./myprog &lt; data &gt; /dev/null
</code></pre><p><code>/dev/null</code>是一个特殊的文件, 任何试图输出到它的信息都会被丢弃, 你能想到这是怎么实现的吗?
总之, 上面的命令将<code>myprog</code>的输出过滤掉, 保留了<code>time</code>的计时结果, 方便又整洁.</p>
<h2 id="使用makefile管理工程">使用Makefile管理工程</h2>
<p>大规模的工程中通常含有几十甚至成百上千个源文件(Linux内核源码有25000+的源文件),
分别键入命令对它们进行编译是十分低效的.
Linux提供了一个高效管理工程文件的工具: GNU Make.
我们首先从一个简单的例子开始, 考虑上文提到的Hello World的例子,
在<code>hello.c</code>所在目录下新建一个文件<code>Makefile</code>, 输入以下内容并保存:</p>
<pre><code class="lang-makefile">hello:hello.c
    gcc hello.c -o hello    <span class="hljs-comment"># 注意开头的tab, 而不是空格</span>

<span class="hljs-meta"><span class="hljs-meta-keyword">.PHONY</span>: clean</span>

<span class="hljs-section">clean:</span>
    rm hello    <span class="hljs-comment"># 注意开头的tab, 而不是空格</span>
</code></pre>
<p>返回命令行, 键入<code>make</code>, 你会发现<code>make</code>程序调用了<code>gcc</code>进行编译.
<code>Makefile</code>文件由若干规则组成, 规则的格式一般如下:</p>
<pre><code>目标文件名:依赖文件列表
    用于生成目标文件的命令序列   # 注意开头的tab, 而不是空格
</code></pre><p>我们来解释一下上文中的<code>hello</code>规则.
这条规则告诉<code>make</code>程序, 需要生成的目标文件是<code>hello</code>, 它依赖于文件<code>hello.c</code>,
通过执行命令<code>gcc hello.c -o hello</code>来生成<code>hello</code>文件.</p>
<p>如果你连续多次执行<code>make</code>, 你会得到"文件已经是最新版本"的提示信息, 这是<code>make</code>程序智能管理的功能.
如果目标文件已经存在, 并且它比所有依赖文件都要"新", 用于生成目标的命令就不会被执行.
你能想到<code>make</code>程序是如何进行"新"和"旧"的判断的吗?</p>
<p>上面例子中的<code>clean</code>规则比较特殊, 它并不是用来生成一个名为<code>clean</code>的文件,
而是用于清除编译结果, 并且它不依赖于其它任何文件.
<code>make</code>程序总是希望通过执行命令来生成目标, 但我们给出的命令<code>rm hello</code>并不是用来生成<code>clean</code>文件,
因此这样的命令总是会被执行.
你需要键入<code>make clean</code>命令来告诉<code>make</code>程序执行<code>clean</code>规则,
这是因为<code>make</code>默认执行在<code>Makefile</code>中文本序排在最前面的规则.
但如果很不幸地, 目录下已经存在了一个名为<code>clean</code>的文件, 执行<code>make clean</code>会得到"文件已经是最新版本"的提示.
解决这个问题的方法是在<code>Makefile</code>中加入一行<code>PHONY: clean</code>, 用于指示"<code>clean</code>是一个伪目标".
这样以后, <code>make</code>程序就不会判断目标文件的新旧, 伪目标相应的命令序列总是会被执行.</p>
<p>对于一个规模稍大一点的工程, <code>Makefile</code>文件还会使用变量, 函数, 调用Shell命令, 隐含规则等功能.
如果你希望学习如何更好地编写一个<code>Makefile</code>, 请到互联网上搜索相关资料.</p>
<h2 id="综合示例-教务刷分脚本">综合示例: 教务刷分脚本</h2>
<p>使用编辑器编辑文件<code>jw.sh</code>为如下内容(另外由于教务网站的升级改版, 目前此脚本可能不能实现正确的功能):</p>
<pre><code class="lang-sh"><span class="hljs-meta">#!/bin/bash</span>
save_file=<span class="hljs-string">"score"</span> <span class="hljs-comment"># 临时文件</span>
semester=20102 <span class="hljs-comment"># 刷分的学期, 20102代表2010年第二学期</span>
jw_home=<span class="hljs-string">"http://jwas3.nju.edu.cn:8080/jiaowu"</span> <span class="hljs-comment"># 教务网站首页地址</span>
jw_login=<span class="hljs-string">"http://jwas3.nju.edu.cn:8080/jiaowu/login.do"</span> <span class="hljs-comment"># 登录页面地址</span>
jw_query=<span class="hljs-string">"http://jwas3.nju.edu.cn:8080/jiaowu/student/studentinfo/achievementinfo.do?method=searchTermList&amp;termCode=<span class="hljs-variable">$semester</span>"</span> <span class="hljs-comment"># 分数查询页面地址</span>

name=<span class="hljs-string">"09xxxxxxx"</span> <span class="hljs-comment"># 你的学号</span>
passwd=<span class="hljs-string">"xxxxxxxx"</span> <span class="hljs-comment"># 你的密码</span>

<span class="hljs-comment"># 请求jw_home地址, 并从中找到返回的cookie. cookie信息在http头中的JSESSIONID字段中</span>
cookie=`wget -q -O - <span class="hljs-variable">$jw_home</span> --save-headers | \
    sed -n <span class="hljs-string">'s/Set-Cookie: JSESSIONID=\([0-9A-Z]\+\);.*$/\1/p'</span>`
<span class="hljs-comment"># 用户登录, 使用POST方法请求jw_login地址, 并在POST请求中加入userName和password</span>
wget -q -O - --header=<span class="hljs-string">"Cookie:JSESSIONID=<span class="hljs-variable">$cookie</span>"</span> --post-data \
    <span class="hljs-string">"userName=<span class="hljs-variable">${name}</span>&amp;password=<span class="hljs-variable">${passwd}</span>"</span> <span class="hljs-string">"<span class="hljs-variable">$jw_login</span>"</span> &amp;&gt; /dev/null
<span class="hljs-comment"># 登录完毕后, 请求分数查询页面. 此时会返回html页面并输出到标准输出. 我们将输出重定向到文件"tmp"中.</span>
wget -q -O - --header=<span class="hljs-string">"Cookie:JSESSIONID=<span class="hljs-variable">$cookie</span>"</span> <span class="hljs-string">"<span class="hljs-variable">$jw_query</span>"</span> &gt; tmp
<span class="hljs-comment"># 获取分数列表. 因为教务网站的代码实在是实现得不太规整, 我们又想保留shell的风味, 所以用了比较繁琐的sed和awk处理. list变量中会包含课程名称的列表.</span>
list=`cat tmp | sed -n <span class="hljs-string">'/&lt;table.*TABLE_BODY.*&gt;/,/&lt;\/table&gt;/p'</span> \
        | sed <span class="hljs-string">'/&lt;--/,/--&gt;/d'</span> | grep td \
        | awk <span class="hljs-string">'NR%11==3'</span> | sed <span class="hljs-string">'s/^.*&gt;\(.*\)&lt;.*$/\1/g'</span>`
<span class="hljs-comment"># 对list中的每一门课程, 都得到它的分数</span>
<span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> <span class="hljs-variable">$list</span>; <span class="hljs-keyword">do</span>
    score=`cat tmp | grep -A 20 <span class="hljs-variable">$item</span> | awk <span class="hljs-string">"NR==18"</span> | sed -n <span class="hljs-string">'/^.*\..*$/p'</span>`
    score=`<span class="hljs-built_in">echo</span> <span class="hljs-variable">$score</span>`
    <span class="hljs-keyword">if</span> [[ <span class="hljs-variable">
        {% raw %}
            ${#score}
            if [[ ${#resources[@]} -gt 0 ]]
        {% endraw %}
    </span> != 0 ]]; <span class="hljs-keyword">then</span> <span class="hljs-comment"># 如果存在成绩</span>
        grep <span class="hljs-variable">$item</span> <span class="hljs-variable">$save_file</span> &amp;&gt;/dev/null <span class="hljs-comment"># 查找分数是否显示过</span>
        <span class="hljs-keyword">if</span> [[ $? != 0 ]]; <span class="hljs-keyword">then</span> <span class="hljs-comment"># 如果没有显示过</span>
        <span class="hljs-comment"># 考虑到尝试的同学可能没有安装notify-send工具, 这里改成echo  -- yzh</span>
            <span class="hljs-comment"># notify-send "新成绩：$item $score" # 弹出窗口显示新成绩</span>
            <span class="hljs-built_in">echo</span> <span class="hljs-string">"新成绩：<span class="hljs-variable">$item</span> <span class="hljs-variable">$score</span>"</span> <span class="hljs-comment"># 在终端里输出新成绩</span>
            <span class="hljs-built_in">echo</span> <span class="hljs-variable">$item</span> &gt;&gt; <span class="hljs-variable">$save_file</span> <span class="hljs-comment"># 将课程标记为已显示</span>
        <span class="hljs-keyword">fi</span>
    <span class="hljs-keyword">fi</span>
<span class="hljs-keyword">done</span>
</code></pre>
<p>运行这个例子需要在命令行中输入<code>bash jw.sh</code>, 用bash解释器执行这一脚本.
如果希望定期运行这一脚本, 可以使用Linux的标准工具之一: <code>cron</code>.
将命令添加到crontab就能实现定期自动刷新.</p>
<p>为了理解这个例子, 首先需要一些HTTP协议的基础知识.
HTTP请求实际就是来回传送的文本流——浏览器(或我们例子中的爬虫)生成一个文本格式的HTTP请求,
包括header和content, 以文本的形式通过网络传送给服务器.
服务器根据请求内容(header中包含请求的URL以及浏览器等其他信息), 生成页面并返回.</p>
<p>用户登录的实现, 就是通过HTTP头中header中的cookie实现的.
当浏览器第一次请求页面时, 服务器会返回一串字符, 用来标识浏览器的这次访问.
从此以后, 所有与该网站交互时, 浏览器都会在HTTP请求的header中加入这个字符串, 这样服务器就"记住"了浏览器的访问.
当完成登录操作(将用户名和密码发送到服务器)后,
服务器就知道这个cookie隐含了一个合法登录的帐号, 从而能够根据帐号信息发送成绩.</p>
<p>得到包含了成绩信息的html文档之后, 剩下的事情就是解析它了.
我们用了大量的<code>sed</code>和<code>awk</code>完成这件事情, 同学们不用去深究其中的细节,
只需知道我们从文本中提取出了课程名和成绩, 并且将没有显示过的成绩显示出来.</p>
<p>我们讲解这个例子主要是为了说明新环境下的工作方式, 以及实践Unix哲学:</p>
<ul>
<li>每个程序只做一件事, 但做到极致</li>
<li>用程序之间的相互协作来解决复杂问题</li>
<li>每个程序都采用文本作为输入和输出, 这会使程序更易于使用</li>
</ul>
<p>一个Linux老手可以用脚本完成各式各样的任务: 在日志中筛选想要的内容, 搭建一个临时HTTP服务器(核心是使用<code>nc</code>工具)等等.
功能齐全的标准工具使Linux成为工程师, 研究员和科学家的最佳搭档.</p>
<footer class="page-footer-ex"> <span class="page-footer-ex-copyright"> By <a href="https://sashimi-yzh.github.io/" target="_blank">Zihao Yu</a>, 采用<a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank">知识共享 署名-非商业性使用-相同方式共享 3.0 中国大陆 许可协议</a>发布 </span>            <span class="page-footer-ex-footer-update"> 此页面修订于:  2023-07-08 23:30:42 </span> </footer>
</section>
</div>
<div class="search-results">
<div class="has-results">
<h1 class="search-results-title"><span class="search-results-count"></span> results matching "<span class="search-query"></span>"</h1>
<ul class="search-results-list"></ul>
</div>
<div class="no-results">
<h1 class="search-results-title">No results matching "<span class="search-query"></span>"</h1>
</div>
</div>
</div>
</div>
</div>
</div>
<a aria-label="Previous page: 为什么要学习计算机系统基础" class="navigation navigation-prev" href="why.html">
<i class="fa fa-angle-left"></i>
</a>
<a aria-label="Next page: man入门教程" class="navigation navigation-next" href="man.html">
<i class="fa fa-angle-right"></i>
</a>
</div>
<script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Linux入门教程","level":"1.7.3","depth":2,"next":{"title":"man入门教程","level":"1.7.4","depth":2,"path":"man.md","ref":"man.md","articles":[]},"previous":{"title":"为什么要学习计算机系统基础","level":"1.7.2","depth":2,"path":"why.md","ref":"why.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"3.x.x","theme":"default","variables":{},"plugins":["theme-comscore","intopic-toc","localized-footer","page-footer-ex","callouts"],"pluginsConfig":{"callouts":{"option":{"alert":"info","picto":"fa-edit"},"flag":{"alert":"success","picto":"fa-flag"},"question":{"alert":"info","picto":"fa-question-circle"},"info":{"alert":"info","picto":"fa-info-circle"},"todo":{"alert":"warning","picto":"fa-edit"},"caution":{"alert":"danger","picto":"fa-bullhorn"},"danger":{"alert":"danger","picto":"fa-exclamation"},"showTypeInHeader":false},"intopic-toc":{"isCollapsed":false,"isScrollspyActive":true,"label":"导航","maxDepth":6,"mode":"nested","selector":".markdown-section h2, .markdown-section h3, .markdown-section h4","visible":true},"page-footer-ex":{"copyright":"By [Zihao Yu](https://sashimi-yzh.github.io/), 采用[知识共享 署名-非商业性使用-相同方式共享 3.0 中国大陆 许可协议](http://creativecommons.org/licenses/by-nc-sa/3.0/cn/)发布","markdown":true,"update_format":"YYYY-MM-DD HH:mm:ss","update_label":"此页面修订于: "},"search":{},"localized-footer":{"filename":"FOOTER.md","hline":"true"},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"theme":"white","family":"sans","size":2},"highlight":{},"theme-comscore":{},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles.css","pdf":"styles.css"}},"file":{"path":"linux.md","mtime":"2023-07-08T15:30:42.161Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2023-12-05T03:26:43.464Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>
{% endblock %}