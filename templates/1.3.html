{% extends 'base.html' %}
{% block head %}
<title>RTFSC · GitBook</title>
<link href="1.4.html" rel="next"/>
<link href="1.2.html" rel="prev"/>
{% endblock %}
{% block body %}
<div class="book">
<div class="book-summary">
<div id="book-search-input" role="search">
<input placeholder="Type to search" type="text"/>
</div>
<nav role="navigation">
<ul class="summary">
<li class="chapter" data-level="1.1" data-path="index.html">
<a href="index.html">
            
                    
                    Introduction
            
                </a>
</li>
<li class="chapter" data-level="1.2" data-path="PA0.html">
<a href="PA0.html">
            
                    
                    PA0 - 世界诞生的前夜: 开发环境配置
            
                </a>
<ul class="articles">
<li class="chapter" data-level="1.2.1" data-path="0.1.html">
<a href="0.1.html">
            
                    
                    Installing GNU/Linux
            
                </a>
</li>
<li class="chapter" data-level="1.2.2" data-path="0.2.html">
<a href="0.2.html">
            
                    
                    First Exploration with GNU/Linux
            
                </a>
</li>
<li class="chapter" data-level="1.2.3" data-path="0.3.html">
<a href="0.3.html">
            
                    
                    Installing Tools
            
                </a>
</li>
<li class="chapter" data-level="1.2.4" data-path="0.4.html">
<a href="0.4.html">
            
                    
                    Configuring vim
            
                </a>
</li>
<li class="chapter" data-level="1.2.5" data-path="0.5.html">
<a href="0.5.html">
            
                    
                    More Exploration
            
                </a>
</li>
<li class="chapter" data-level="1.2.6" data-path="0.6.html">
<a href="0.6.html">
            
                    
                    Getting Source Code for PAs
            
                </a>
</li>
</ul>
</li>
<li class="chapter" data-level="1.3" data-path="PA1.html">
<a href="PA1.html">
            
                    
                    PA1 - 开天辟地的篇章: 最简单的计算机
            
                </a>
<ul class="articles">
<li class="chapter" data-level="1.3.1" data-path="1.1.html">
<a href="1.1.html">
            
                    
                    在开始愉快的PA之旅之前
            
                </a>
</li>
<li class="chapter" data-level="1.3.2" data-path="1.2.html">
<a href="1.2.html">
            
                    
                    开天辟地的篇章
            
                </a>
</li>
<li class="chapter active" data-level="1.3.3" data-path="1.3.html">
<a href="1.3.html">
            
                    
                    RTFSC
            
                </a>
</li>
<li class="chapter" data-level="1.3.4" data-path="1.4.html">
<a href="1.4.html">
            
                    
                    基础设施
            
                </a>
</li>
<li class="chapter" data-level="1.3.5" data-path="1.5.html">
<a href="1.5.html">
            
                    
                    表达式求值
            
                </a>
</li>
<li class="chapter" data-level="1.3.6" data-path="1.6.html">
<a href="1.6.html">
            
                    
                    监视点
            
                </a>
</li>
<li class="chapter" data-level="1.3.7" data-path="1.7.html">
<a href="1.7.html">
            
                    
                    如何阅读手册
            
                </a>
</li>
</ul>
</li>
<li class="chapter" data-level="1.4" data-path="PA2.html">
<a href="PA2.html">
            
                    
                    PA2 - 简单复杂的机器: 冯诺依曼计算机系统
            
                </a>
<ul class="articles">
<li class="chapter" data-level="1.4.1" data-path="2.1.html">
<a href="2.1.html">
            
                    
                    不停计算的机器
            
                </a>
</li>
<li class="chapter" data-level="1.4.2" data-path="2.2.html">
<a href="2.2.html">
            
                    
                    RTFSC(2)
            
                </a>
</li>
<li class="chapter" data-level="1.4.3" data-path="2.3.html">
<a href="2.3.html">
            
                    
                    程序, 运行时环境与AM
            
                </a>
</li>
<li class="chapter" data-level="1.4.4" data-path="2.4.html">
<a href="2.4.html">
            
                    
                    基础设施(2)
            
                </a>
</li>
<li class="chapter" data-level="1.4.5" data-path="2.5.html">
<a href="2.5.html">
            
                    
                    输入输出
            
                </a>
</li>
</ul>
</li>
<li class="chapter" data-level="1.5" data-path="PA3.html">
<a href="PA3.html">
            
                    
                    PA3 - 穿越时空的旅程: 批处理系统
            
                </a>
<ul class="articles">
<li class="chapter" data-level="1.5.1" data-path="3.1.html">
<a href="3.1.html">
            
                    
                    最简单的操作系统
            
                </a>
</li>
<li class="chapter" data-level="1.5.2" data-path="3.2.html">
<a href="3.2.html">
            
                    
                    穿越时空的旅程
            
                </a>
</li>
<li class="chapter" data-level="1.5.3" data-path="3.3.html">
<a href="3.3.html">
            
                    
                    用户程序和系统调用
            
                </a>
</li>
<li class="chapter" data-level="1.5.4" data-path="3.4.html">
<a href="3.4.html">
            
                    
                    文件系统
            
                </a>
</li>
<li class="chapter" data-level="1.5.5" data-path="3.5.html">
<a href="3.5.html">
            
                    
                    精彩纷呈的应用程序
            
                </a>
</li>
</ul>
</li>
<li class="chapter" data-level="1.6" data-path="PA4.html">
<a href="PA4.html">
            
                    
                    PA4 - 虚实交错的魔法: 分时多任务
            
                </a>
<ul class="articles">
<li class="chapter" data-level="1.6.1" data-path="4.1.html">
<a href="4.1.html">
            
                    
                    多道程序
            
                </a>
</li>
<li class="chapter" data-level="1.6.2" data-path="4.2.html">
<a href="4.2.html">
            
                    
                    虚实交错的魔法
            
                </a>
</li>
<li class="chapter" data-level="1.6.3" data-path="4.3.html">
<a href="4.3.html">
            
                    
                    超越容量的界限
            
                </a>
</li>
<li class="chapter" data-level="1.6.4" data-path="4.4.html">
<a href="4.4.html">
            
                    
                    来自外部的声音
            
                </a>
</li>
<li class="chapter" data-level="1.6.5" data-path="4.5.html">
<a href="4.5.html">
            
                    
                    编写不朽的传奇
            
                </a>
</li>
</ul>
</li>
<li class="chapter" data-level="1.7" data-path="blank.html">
<a href="blank.html">
            
                    
                    杂项
            
                </a>
<ul class="articles">
<li class="chapter" data-level="1.7.1" data-path="FAQ.html">
<a href="FAQ.html">
            
                    
                    常见问题(FAQ)
            
                </a>
</li>
<li class="chapter" data-level="1.7.2" data-path="why.html">
<a href="why.html">
            
                    
                    为什么要学习计算机系统基础
            
                </a>
</li>
<li class="chapter" data-level="1.7.3" data-path="linux.html">
<a href="linux.html">
            
                    
                    Linux入门教程
            
                </a>
</li>
<li class="chapter" data-level="1.7.4" data-path="man.html">
<a href="man.html">
            
                    
                    man入门教程
            
                </a>
</li>
<li class="chapter" data-level="1.7.5" data-path="git.html">
<a href="git.html">
            
                    
                    git入门教程
            
                </a>
</li>
<li class="chapter" data-level="1.7.6" data-path="nemu-isa-api.html">
<a href="nemu-isa-api.html">
            
                    
                    NEMU ISA相关API说明文档
            
                </a>
</li>
<li class="chapter" data-level="1.7.7" data-path="changelog.html">
<a href="changelog.html">
            
                    
                    更新日志
            
                </a>
</li>
<li class="chapter" data-level="1.7.8" data-path="i386-intro.html">
<a href="i386-intro.html">
            
                    
                    i386手册指令集阅读指南
            
                </a>
</li>
</ul>
</li>
<li class="divider"></li>
<li>
<a class="gitbook-link" href="https://www.gitbook.com" target="blank">
            Published with GitBook
        </a>
</li>
</ul>
</nav>
</div>
<div class="book-body">
<div class="body-inner">
<div class="book-header" role="navigation">
<!-- Title -->
<h1>
<i class="fa fa-circle-o-notch fa-spin"></i>
<a href=".">RTFSC</a>
</h1>
</div>
<div class="page-wrapper" role="main" tabindex="-1">
<div class="page-inner">
<div id="book-search-results">
<div class="search-noresults">
<section class="normal markdown-section">
<h2 id="rtfsc">RTFSC</h2>
<p>事实上, TRM的实现是如此的简单, 以至于框架代码已经实现它了.
接下来让我们看看, 构成TRM的那些数字电路, 在NEMU的C代码中都是何方神圣.
为了方便叙述, 我们将在NEMU中模拟的计算机称为"客户(guest)计算机",
在NEMU中运行的程序称为"客户程序".</p>
<h3 id="框架代码初探">框架代码初探</h3>
<p>框架代码内容众多, 其中包含了很多在后续阶段中才使用的代码.
随着实验进度的推进, 我们会逐渐解释所有的代码.
 <font color="red">因此在阅读代码的时候, 你只需要关心和当前进度相关的模块就可以了,
不要纠缠于和当前进度无关的代码, 否则将会给你的心灵带来不必要的恐惧.</font></p>
<pre><code>ics2023
├── abstract-machine   # 抽象计算机
├── am-kernels         # 基于抽象计算机开发的应用程序
├── fceux-am           # 红白机模拟器
├── init.sh            # 初始化脚本
├── Makefile           # 用于工程打包提交
├── nemu               # NEMU
└── README.md
</code></pre><p>目前我们只需要关心NEMU子项目中的内容, 其它子项目会在将来进行介绍.
NEMU主要由4个模块构成: monitor, CPU, memory, 设备.
我们已经在上一小节简单介绍了CPU和memory的功能, 设备会在PA2中介绍, 目前不必关心.</p>
<p>Monitor(监视器)模块是为了方便地监控客户计算机的运行状态而引入的.
它除了负责与GNU/Linux进行交互(例如读入客户程序)之外,
还带有调试器的功能, 为NEMU的调试提供了方便的途径.
从概念上来说, monitor并不属于一个计算机的必要组成部分, 但对NEMU来说, 它是必要的基础设施.
如果缺少monitor模块, 对NEMU的调试将会变得十分困难.</p>
<p>代码中<code>nemu/</code>目录下的源文件组织如下(并未列出所有文件):</p>
<pre><code>nemu
├── configs                    # 预先提供的一些配置文件
├── include                    # 存放全局使用的头文件
│   ├── common.h               # 公用的头文件
│   ├── config                 # 配置系统生成的头文件, 用于维护配置选项更新的时间戳
│   ├── cpu
│   │   ├── cpu.h
│   │   ├── decode.h           # 译码相关
│   │   ├── difftest.h
│   │   └── ifetch.h           # 取指相关
│   ├── debug.h                # 一些方便调试用的宏
│   ├── device                 # 设备相关
│   ├── difftest-def.h
│   ├── generated
│   │   └── autoconf.h         # 配置系统生成的头文件, 用于根据配置信息定义相关的宏
│   ├── isa.h                  # ISA相关
│   ├── macro.h                # 一些方便的宏定义
│   ├── memory                 # 访问内存相关
│   └── utils.h
├── Kconfig                    # 配置信息管理的规则
├── Makefile                   # Makefile构建脚本
├── README.md
├── resource                   # 一些辅助资源
├── scripts                    # Makefile构建脚本
│   ├── build.mk
│   ├── config.mk
│   ├── git.mk                 # git版本控制相关
│   └── native.mk
├── src                        # 源文件
│   ├── cpu
│   │   └── cpu-exec.c         # 指令执行的主循环
│   ├── device                 # 设备相关
│   ├── engine
│   │   └── interpreter        # 解释器的实现
│   ├── filelist.mk
│   ├── isa                    # ISA相关的实现
│   │   ├── mips32
│   │   ├── riscv32
│   │   ├── riscv64
│   │   └── x86
│   ├── memory                 # 内存访问的实现
│   ├── monitor
│   │   ├── monitor.c
│   │   └── sdb                # 简易调试器
│   │       ├── expr.c         # 表达式求值的实现
│   │       ├── sdb.c          # 简易调试器的命令处理
│   │       └── watchpoint.c   # 监视点的实现
│   ├── nemu-main.c            # 你知道的...
│   └── utils                  # 一些公共的功能
│       ├── log.c              # 日志文件相关
│       ├── rand.c
│       ├── state.c
│       └── timer.c
└── tools                      # 一些工具
    ├── fixdep                 # 依赖修复, 配合配置系统进行使用
    ├── gen-expr
    ├── kconfig                # 配置系统
    ├── kvm-diff
    ├── qemu-diff
    └── spike-diff
</code></pre><p>为了支持不同的ISA, 框架代码把NEMU分成两部分: ISA无关的基本框架和ISA相关的具体实现.
NEMU把ISA相关的代码专门放在<code>nemu/src/isa/</code>目录下,
并通过<code>nemu/include/isa.h</code>提供ISA相关API的声明.
这样以后, <code>nemu/src/isa/</code>之外的其它代码就展示了NEMU的基本框架.
这样做有两点好处:</p>
<ul>
<li>有助于我们认识不同ISA的共同点: 无论是哪种ISA的客户计算机, 它们都具有相同的基本框架</li>
<li>体现抽象的思想: 框架代码将ISA之间的差异抽象成API, 基本框架会调用这些API, 从而无需关心ISA的具体细节.
如果你将来打算选择一个不同的ISA来进行二周目的攻略,
你就能明显体会到抽象的好处了: 基本框架的代码完全不用修改!</li>
</ul>
<p><a href="nemu-isa-api.html">这个页面</a>对上述API进行了整理, 供将来查阅使用, 目前你无需完全明白它们的作用.
"抽象"是计算机系统中一个非常重要的概念, 如果你现在不明白抽象的意义,
不必担心, 在PA的后续内容中, 你会一次又一次地遇到它.</p>
<p>大致了解上述的目录树之后, 你就可以开始阅读代码了.
至于从哪里开始, 就不用多费口舌了吧.</p>
<div class="panel panel-info"><div class="panel-heading"><h5 class="panel-title" id="需要多费口舌吗"><i class="fa fa-question-circle"></i> 需要多费口舌吗?</h5></div><div class="panel-body"><p>嗯... 如果你觉得提示还不够, 那就来一个劲爆的:
回忆程序设计课的内容, 一个程序从哪里开始执行呢?</p><p>如果你不屑于回答这个问题, 不妨先冷静下来.
其实这是一个值得探究的问题, 你会在将来重新审视它.</p></div></div>
<h3 id="配置系统和项目构建">配置系统和项目构建</h3>
<p>在真正开始阅读代码之前, 我们先来简单介绍一下NEMU项目中的配置系统和项目构建.</p>
<h4 id="配置系统kconfig">配置系统kconfig</h4>
<p>在一个有一定规模的项目中, 可配置选项的数量可能会非常多, 而且配置选项之间可能会存在关联,
比如打开配置选项A之后, 配置选项B就必须是某个值.
直接让开发者去管理这些配置选项是很容易出错的,
比如修改选项A之后, 可能会忘记修改和选项A有关联的选项B.
配置系统的出现则是为了解决这个问题.</p>
<p>NEMU中的配置系统位于<code>nemu/tools/kconfig</code>, 它来源于GNU/Linux项目中的kconfig, 我们进行了少量简化.
kconfig定义了一套简单的语言, 开发者可以使用这套语言来编写"配置描述文件".
在"配置描述文件"中, 开发者可以描述:</p>
<ul>
<li>配置选项的属性, 包括类型, 默认值等</li>
<li>不同配置选项之间的关系</li>
<li>配置选项的层次关系</li>
</ul>
<p>在NEMU项目中, "配置描述文件"的文件名都为<code>Kconfig</code>, 如<code>nemu/Kconfig</code>.
当你键入<code>make menuconfig</code>的时候, 背后其实发生了如下事件:</p>
<ul>
<li>检查<code>nemu/tools/kconfig/build/mconf</code>程序是否存在, 若不存在, 则编译并生成<code>mconf</code></li>
<li>检查<code>nemu/tools/kconfig/build/conf</code>程序是否存在, 若不存在, 则编译并生成<code>conf</code></li>
<li>运行命令<code>mconf nemu/Kconfig</code>, 此时<code>mconf</code>将会解析<code>nemu/Kconfig</code>中的描述,
以菜单树的形式展示各种配置选项, 供开发者进行选择</li>
<li>退出菜单时, <code>mconf</code>会把开发者选择的结果记录到<code>nemu/.config</code>文件中</li>
<li>运行命令<code>conf --syncconfig nemu/Kconfig</code>, 此时<code>conf</code>将会解析<code>nemu/Kconfig</code>中的描述,
并读取选择结果<code>nemu/.config</code>, 结合两者来生成如下文件:<ul>
<li>可以被包含到C代码中的宏定义(<code>nemu/include/generated/autoconf.h</code>),
这些宏的名称都是形如<code>CONFIG_xxx</code>的形式</li>
<li>可以被包含到Makefile中的变量定义(<code>nemu/include/config/auto.conf</code>)</li>
<li>可以被包含到Makefile中的, 和"配置描述文件"相关的依赖规则(<code>nemu/include/config/auto.conf.cmd</code>),
为了阅读代码, 我们可以不必关心它</li>
<li>通过时间戳来维护配置选项变化的目录树<code>nemu/include/config/</code>,
它会配合另一个工具<code>nemu/tools/fixdep</code>来使用, 用于在更新配置选项后节省不必要的文件编译,
为了阅读代码, 我们可以不必关心它</li>
</ul>
</li>
</ul>
<p>所以, 目前我们只需要关心配置系统生成的如下文件:</p>
<ul>
<li><code>nemu/include/generated/autoconf.h</code>, 阅读C代码时使用</li>
<li><code>nemu/include/config/auto.conf</code>, 阅读Makefile时使用</li>
</ul>
<h4 id="项目构建和makefile">项目构建和Makefile</h4>
<p>NEMU的Makefile会稍微复杂一些, 它具备如下功能:</p>
<h5 id="与配置系统进行关联">与配置系统进行关联</h5>
<p>通过包含<code>nemu/include/config/auto.conf</code>, 与kconfig生成的变量进行关联.
因此在通过menuconfig更新配置选项后, Makefile的行为可能也会有所变化.</p>
<h5 id="文件列表filelist">文件列表(filelist)</h5>
<p>通过文件列表(filelist)决定最终参与编译的源文件.
在<code>nemu/src</code>及其子目录下存在一些名为<code>filelist.mk</code>的文件,
它们会根据menuconfig的配置对如下4个变量进行维护:</p>
<ul>
<li><code>SRCS-y</code> - 参与编译的源文件的候选集合</li>
<li><code>SRCS-BLACKLIST-y</code> - 不参与编译的源文件的黑名单集合</li>
<li><code>DIRS-y</code> - 参与编译的目录集合, 该目录下的所有文件都会被加入到<code>SRCS-y</code>中</li>
<li><code>DIRS-BLACKLIST-y</code> - 不参与编译的目录集合, 该目录下的所有文件都会被加入到<code>SRCS-BLACKLIST-y</code>中</li>
</ul>
<p>Makefile会包含项目中的所有<code>filelist.mk</code>文件, 对上述4个变量的追加定义进行汇总,
最终会过滤出在<code>SRCS-y</code>中但不在<code>SRCS-BLACKLIST-y</code>中的源文件,
来作为最终参与编译的源文件的集合.</p>
<p>上述4个变量还可以与menuconfig的配置结果中的布尔选项进行关联,
例如<code>DIRS-BLACKLIST-$(CONFIG_TARGET_AM) += src/monitor/sdb</code>,
当我们在menuconfig中选择了<code>TARGET_AM</code>相关的布尔选项时,
kconfig最终会在<code>nemu/include/config/auto.conf</code>中生成形如<code>CONFIG_TARGET_AM=y</code>的代码,
对变量进行展开后将会得到<code>DIRS-BLACKLIST-y += src/monitor/sdb</code>;
当我们在menuconfig中未选择<code>TARGET_AM</code>相关的布尔选项时,
kconfig将会生成形如<code>CONFIG_TARGET_AM=n</code>的代码, 或者未对<code>CONFIG_TARGET_AM</code>进行定义,
此时将会得到<code>DIRS-BLACKLIST-n += src/monitor/sdb</code>,
或者<code>DIRS-BLACKLIST- += src/monitor/sdb</code>,
这两种情况都不会影响<code>DIRS-BLACKLIST-y</code>的值, 从而实现了如下效果:</p>
<pre><code>在menuconfig中选中TARGET_AM时, nemu/src/monitor/sdb目录下的所有文件都不会参与编译.
</code></pre><h5 id="编译和链接">编译和链接</h5>
<p>Makefile的编译规则在<code>nemu/scripts/build.mk</code>中定义:</p>
<pre><code class="lang-makefile">$(OBJ_DIR)/%.o: %.c
  @echo + CC $&lt;
  @mkdir -p $(dir $@)
  @$(CC) $(CFLAGS) -c -o $@ $&lt;
  $(call call_fixdep, $(@:.o=.d), $@)
</code></pre>
<p>其中关于<code>$@</code>和<code>$&lt;</code>等符号的含义, 可以RTFM进行了解.
<code>call_fixdep</code>的调用用于生成更合理的依赖关系,
目前我们主要关注编译的命令, 因此可以先忽略<code>call_fixdep</code>.</p>
<p>我们可以先查看<code>make</code>过程中都运行了哪些命令, 然后反过来理解<code>$(CFLAGS)</code>等变量的值.
为此, 我们可以键入<code>make -nB</code>, 它会让<code>make</code>程序以"只输出命令但不执行"的方式强制构建目标.
运行后, 你可以看到很多形如</p>
<pre><code>gcc -O2 -MMD -Wall -Werror -I/home/user/ics2023/nemu/include
-I/home/user/ics2023/nemu/src/engine/interpreter -I/home/use
r/ics2023/nemu/src/isa/riscv32/include -O2    -D__GUEST_ISA__
=riscv32  -c -o /home/user/ics2023/nemu/build/obj-riscv32-nem
u-interpreter/src/utils/timer.o src/utils/timer.c
</code></pre><p>的输出, 这样你就很容易理解上述Makefile变量的值了:</p>
<pre><code>$(CC) -&gt; gcc
$@ -&gt; /home/user/ics2023/nemu/build/obj-riscv32-nemu-interpreter/src/utils/timer.o
$&lt; -&gt; src/utils/timer.c
$(CFLAGS) -&gt; 剩下的内容
</code></pre><p>于是你就可以根据上述输出结果和Makefile反推<code>$(CFLAGS)</code>的值是如何形成的.
因为编译每个文件的命令都很类似, 当你理解了一个源文件的编译之后,
你就能类推到其它源文件的编译过程了. 同理, 你也可以按照上述方法理解最后的链接命令.</p>
<h3 id="准备第一个客户程序">准备第一个客户程序</h3>
<p>我们已经知道, NEMU是一个用来执行客户程序的程序, 但客户程序一开始并不存在于客户计算机中.
我们需要将客户程序读入到客户计算机中, 这件事是monitor来负责的.
于是NEMU在开始运行的时候, 首先会调用<code>init_monitor()</code>函数(在<code>nemu/src/monitor/monitor.c</code>中定义)
来进行一些和monitor相关的初始化工作.</p>
<div class="panel panel-info"><div class="panel-heading"><h5 class="panel-title" id="kconfig生成的宏与条件编译"><i class="fa fa-question-circle"></i> kconfig生成的宏与条件编译</h5></div><div class="panel-body"><p>我们已经在上文提到过, kconfig会根据配置选项的结果在
<code>nemu/include/generated/autoconf.h</code>中定义一些形如<code>CONFIG_xxx</code>的宏,
我们可以在C代码中通过条件编译的功能对这些宏进行测试, 来判断是否编译某些代码.
例如, 当<code>CONFIG_DEVICE</code>这个宏没有定义时, 设备相关的代码就无需进行编译.</p><p>为了编写更紧凑的代码, 我们在<code>nemu/include/macro.h</code>中定义了一些专门用来对宏进行测试的宏.
例如<code>IFDEF(CONFIG_DEVICE, init_device());</code>表示,
如果定义了<code>CONFIG_DEVICE</code>, 才会调用<code>init_device()</code>函数;
而<code>MUXDEF(CONFIG_TRACE, "ON", "OFF")</code>则表示, 如果定义了<code>CONFIG_TRACE</code>,
则预处理结果为<code>"ON"</code>(<code>"OFF"</code>在预处理后会消失), 否则预处理结果为<code>"OFF"</code>.</p><p>这些宏的功能非常神奇, 你知道这些宏是如何工作的吗?</p></div></div>
<!-- -->
<div class="panel panel-info"><div class="panel-heading"><h5 class="panel-title" id="为什么全部都是函数"><i class="fa fa-question-circle"></i> 为什么全部都是函数?</h5></div><div class="panel-body"><p>阅读<code>init_monitor()</code>函数的代码, 你会发现里面全部都是函数调用.
按道理, 把相应的函数体在<code>init_monitor()</code>中展开也不影响代码的正确性.
相比之下, 在这里使用函数有什么好处呢?</p></div></div>
<p>我们对这些初始化工作进行一些说明. <code>parse_args()</code>, <code>init_rand()</code>,
<code>init_log()</code>和<code>init_mem()</code>并没有什么深奥的内容, 直接RTFSC就行.</p>
<div class="panel panel-success"><div class="panel-heading"><h5 class="panel-title" id="参数的处理过程"><i class="fa fa-lightbulb-o"></i> 参数的处理过程</h5></div><div class="panel-body"><p><code>parse_args()</code>中调用了一个你也许不太熟悉的函数<code>getopt_long()</code>,
框架代码通过它来对参数进行解析, 具体的行为可以查阅<code>man 3 getopt_long</code>.</p></div></div>
<!-- -->
<div class="panel panel-info"><div class="panel-heading"><h5 class="panel-title" id="参数的处理过程"><i class="fa fa-question-circle"></i> 参数的处理过程</h5></div><div class="panel-body"><p>另外的一个问题是, 这些参数是从哪里来的呢?</p></div></div>
<p>接下来monitor会调用<code>init_isa()</code>函数(在<code>nemu/src/isa/$ISA/init.c</code>中定义),
来进行一些ISA相关的初始化工作.</p>
<p>第一项工作就是将一个内置的客户程序读入到内存中.
为了理解这项工作, 我们还需要理清三个问题:</p>
<ol>
<li><p>客户程序是什么?
我们知道, 程序是由指令构成的,
而不同ISA的指令也各不相同(想象一下用不同的语言来表达"你好"的意思),
因而程序本身肯定是ISA相关的.
因此, 我们把内置客户程序放在<code>nemu/src/isa/$ISA/init.c</code>中.
内置客户程序的行为非常简单, 它只包含少数几条指令, 甚至算不上在做一些有意义的事情.</p>
</li>
<li><p>内存是什么?
我们可以把内存看作一段连续的存储空间, 而内存又是字节编址的(即一个内存位置存放一个字节的数据),
在C语言中我们就很自然地使用一个<code>uint8_t</code>类型的数组来对内存进行模拟.
NEMU默认为客户计算机提供128MB的物理内存(见<code>nemu/src/memory/paddr.c</code>中定义的<code>pmem</code>),</p>
</li>
<li><p>需要将客户程序读入到内存的什么位置?
为了让客户计算机的CPU可以执行客户程序,
因此我们需要一种方式让客户计算机的CPU知道客户程序的位置.
我们采取一种最简单的方式: 约定.
具体地, 我们让monitor直接把客户程序读入到一个固定的内存位置<code>RESET_VECTOR</code>.
<code>RESET_VECTOR</code>的值在<code>nemu/include/memory/paddr.h</code>中定义.</p>
</li>
</ol>
<div class="panel panel-success"><div class="panel-heading"><h5 class="panel-title" id="bios和计算机启动"><i class="fa fa-lightbulb-o"></i> BIOS和计算机启动</h5></div><div class="panel-body"><p>我们知道内存是一种RAM, 是一种易失性的存储介质, 这意味着计算机刚启动的时候, 内存中的数据都是无意义的;
而BIOS是固化在ROM/Flash中的, 它们都是非易失性的存储介质, BIOS中的内容不会因为断电而丢失.</p><p>因此在真实的计算机系统中, 计算机启动后首先会把控制权交给BIOS,
BIOS经过一系列初始化工作之后, 再从磁盘中将有意义的程序读入内存中执行.
对这个过程的模拟需要了解很多超出本课程范围的细节, 我们在PA中做了简化:
采取约定的方式让CPU直接从约定的内存位置开始执行.</p></div></div>
<!-- -->
<div class="panel panel-info"><div class="panel-heading"><h5 class="panel-title" id="初探操作系统启动"><i class="fa fa-comment-o"></i> 初探操作系统启动</h5></div><div class="panel-body"><p>你使用windows的时候, 开机过程一般都会播放相应的开机动画,
然后不知道怎么就进入登录画面了, 这显然不能满足CSer的求知欲.
事实上, 在GNU/Linux中, 你可以很容易得知操作系统在背后做了些什么.
键入<code>sudo dmesg</code>, 就可以输出操作系统的启动日志, 操作系统的行为一览无余.</p><p>不过, 目前你的知识可能还无法理解其中的奥秘.
但你无需为此感到沮丧, 在PA的中后期, 你将会在NEMU上运行一个小型操作系统Nanos-lite.
虽然和GNU/Linux相比, Nanos-lite可以说是沧海一粟,
但你将会完全明白操作系统启动过程中的一些关键步骤, 操作系统的大门也将会为你敞开.</p></div></div>
<p><code>init_isa()</code>的第二项任务是初始化寄存器, 这是通过<code>restart()</code>函数来实现的.
在CPU中, 寄存器是一个结构化特征较强的存储部件,
在C语言中我们就很自然地使用相应的结构体来描述CPU的寄存器结构.
不同ISA的寄存器结构也各不相同,
为此我们把寄存器结构体<code>CPU_state</code>的定义放在<code>nemu/src/isa/$ISA/include/isa-def.h</code>中,
并在<code>nemu/src/cpu/cpu-exec.c</code>中定义一个全局变量<code>cpu</code>.
初始化寄存器的一个重要工作就是设置<code>cpu.pc</code>的初值,
我们需要将它设置成刚才加载客户程序的内存位置,
这样就可以让CPU从我们约定的内存位置开始执行客户程序了.
对于mips32和riscv32, 它们的0号寄存器总是存放<code>0</code>, 因此我们也需要对其进行初始化.</p>
<div class="panel panel-info"><div class="panel-heading"><h5 class="panel-title" id="物理内存的起始地址"><i class="fa fa-comment-o"></i> 物理内存的起始地址</h5></div><div class="panel-body"><p>x86的物理内存是从0开始编址的, 但对于一些ISA来说却不是这样,
例如mips32和riscv32的物理地址均从<code>0x80000000</code>开始.
因此对于mips32和riscv32, 其<code>CONFIG_MBASE</code>将会被定义成<code>0x80000000</code>.
将来CPU访问内存时, 我们会将CPU将要访问的内存地址映射到<code>pmem</code>中的相应偏移位置,
这是通过<code>nemu/src/memory/paddr.c</code>中的<code>guest_to_host()</code>函数实现的.
例如如果mips32的CPU打算访问内存地址<code>0x80000000</code>, 我们会让它最终访问<code>pmem[0]</code>,
从而可以正确访问客户程序的第一条指令.
这种机制有一个专门的名字, 叫地址映射, 在后续的PA中我们还会再遇到它.</p></div></div>
<p>对于x86, 我们把寄存器结构体的实现作为作业. 为了检查你的实现是否正确,
我们在<code>init_isa()</code>中还调用了<code>reg_test()</code>函数(在<code>nemu/src/isa/x86/reg.c</code>中定义).
具体会在下文的必做题中进行介绍.</p>
<p>Monitor读入客户程序并对寄存器进行初始化后, 这时内存的布局如下:</p>
<pre><code>pmem:

CONFIG_MBASE      RESET_VECTOR
      |                 |
      v                 v
      -----------------------------------------------
      |                 |                  |
      |                 |    guest prog    |
      |                 |                  |
      -----------------------------------------------
                        ^
                        |
                       pc
</code></pre><p>NEMU返回到<code>init_monitor()</code>函数中, 继续调用<code>load_img()</code>函数
(在<code>nemu/src/monitor/monitor.c</code>中定义).
这个函数会将一个有意义的客户程序从<a href="https://en.wikipedia.org/wiki/Disk_image" target="_blank">镜像文件</a>读入到内存,
覆盖刚才的内置客户程序.
这个镜像文件是运行NEMU的一个可选参数, 在运行NEMU的命令中指定.
如果运行NEMU的时候没有给出这个参数, NEMU将会运行内置客户程序.</p>
<p>monitor剩余的初始化工作我们会在后续实验内容中介绍, 目前你无需关心它们的细节,
最后monitor会调用<code>welcome()</code>函数输出欢迎信息.
现在你可以在<code>nemu/</code>目录下编译并运行NEMU了:</p>
<pre><code>make run
</code></pre><div class="panel panel-warning"><div class="panel-heading"><h5 class="panel-title" id="实现x86的寄存器结构体"><i class="fa fa-edit"></i> 实现x86的寄存器结构体</h5></div><div class="panel-body"><p>如果你选择了x86, 框架代码并没有正确地实现用于模拟x86寄存器的结构体<code>x86_CPU_state</code>,
现在你需要实现它了(结构体的定义在<code>nemu/src/isa/x86/include/isa-def.h</code>中).
在<code>init_isa()</code>中调用的<code>reg_test()</code>函数会生成一些随机的数据,
对寄存器结构体的实现进行测试. 若实现不正确, 将会触发assertion fail.
实现正确后, NEMU将不会再触发assertion fail, 而是输出上文提到的欢迎信息.
如果你选择的ISA不是x86, 你可以忽略这道题.</p><p>x86的寄存器结构如下:</p><pre><code> 31                23                15                7               0
+-----------------+-----------------+-----------------+-----------------+
|                                  EAX       AH       AX      AL        |
|-----------------+-----------------+-----------------+-----------------|
|                                  EDX       DH       DX      DL        |
|-----------------+-----------------+-----------------+-----------------|
|                                  ECX       CH       CX      CL        |
|-----------------+-----------------+-----------------+-----------------|
|                                  EBX       BH       BX      BL        |
|-----------------+-----------------+-----------------+-----------------|
|                                  EBP                BP                |
|-----------------+-----------------+-----------------+-----------------|
|                                  ESI                SI                |
|-----------------+-----------------+-----------------+-----------------|
|                                  EDI                DI                |
|-----------------+-----------------+-----------------+-----------------|
|                                  ESP                SP                |
+-----------------+-----------------+-----------------+-----------------+
</code></pre><p>其中</p><ul>
<li><code>EAX</code>, <code>EDX</code>, <code>ECX</code>, <code>EBX</code>, <code>EBP</code>, <code>ESI</code>, <code>EDI</code>, <code>ESP</code>是32位寄存器;</li>
<li><code>AX</code>, <code>DX</code>, <code>CX</code>, <code>BX</code>, <code>BP</code>, <code>SI</code>, <code>DI</code>, <code>SP</code>是16位寄存器;</li>
<li><code>AL</code>, <code>DL</code>, <code>CL</code>, <code>BL</code>, <code>AH</code>, <code>DH</code>, <code>CH</code>, <code>BH</code>是8位寄存器.</li>
</ul><p>但它们在物理上并不是相互独立的, 例如<code>EAX</code>的低16位是<code>AX</code>, 而<code>AX</code>又分成<code>AH</code>和<code>AL</code>.
这样的结构有时候在处理不同长度的数据时能提供一些便利.
关于x86寄存器的更多细节, 请RTFM.</p><p>Hint: 使用匿名union.</p><div class="panel panel-success"><div class="panel-heading"><h5 class="panel-title" id="什么是匿名union"><i class="fa fa-lightbulb-o"></i> 什么是匿名union?</h5></div><div class="panel-body"><p>你有这个疑问是很正常的, 但你接下来应该意识到要去STFW了.</p></div></div><div class="panel panel-info"><div class="panel-heading"><h5 class="panel-title" id="regtest是如何测试你的实现的"><i class="fa fa-question-circle"></i> reg_test()是如何测试你的实现的?</h5></div><div class="panel-body"><p>阅读<code>reg_test()</code>的代码, 思考代码中的<code>assert()</code>条件是根据什么写出来的.</p></div></div></div></div>
<p>运行NEMU之后你应该能看到相应的欢迎信息, 以及你选择的ISA. <font color="red">
请务必确认输出的ISA信息与你选择的ISA一致</font>.
不过你会看到如下的错误信息:</p>
<pre><code>[src/monitor/monitor.c:20 welcome] Exercise: Please remove me in the source code and compile NEMU again.
riscv32-nemu-interpreter: src/monitor/monitor.c:21: welcome: Assertion `0' failed.
</code></pre><p>事实上, 我们已经在PA0的最后介绍过这个错误了.
作为一个练习, 你需要根据错误信息回溯到报告错误的代码中, 然后删除相应代码.
删除后重新编译NEMU, 你将看到这个错误不再出现.</p>
<h3 id="运行第一个客户程序">运行第一个客户程序</h3>
<p>Monitor的初始化工作结束后, <code>main()</code>函数会继续调用<code>engine_start()</code>函数
(在<code>nemu/src/engine/interpreter/init.c</code>中定义).
代码会进入简易调试器(Simple Debugger)的主循环<code>sdb_mainloop()</code>
(在<code>nemu/src/monitor/sdb/sdb.c</code>中定义), 并输出NEMU的命令提示符:</p>
<pre><code>(nemu)
</code></pre><p>简易调试器是monitor的核心功能, 我们可以在命令提示符中输入命令,
对客户计算机的运行状态进行监控和调试.
框架代码已经实现了几个简单的命令, 它们的功能和GDB是很类似的.</p>
<p>在命令提示符后键入<code>c</code>后, NEMU开始进入指令执行的主循环<code>cpu_exec()</code>
(在<code>nemu/src/cpu/cpu-exec.c</code>中定义).
<code>cpu_exec()</code>又会调用<code>execute()</code>, 后者模拟了CPU的工作方式: 不断执行指令.
具体地, 代码将在一个for循环中不断调用<code>exec_once()</code>函数,
这个函数的功能就是我们在上一小节中介绍的内容: 让CPU执行当前PC指向的一条指令, 然后更新PC.</p>
<div class="panel panel-info"><div class="panel-heading"><h5 class="panel-title" id="究竟要执行多久"><i class="fa fa-question-circle"></i> 究竟要执行多久?</h5></div><div class="panel-body"><p>在<code>cmd_c()</code>函数中, 调用<code>cpu_exec()</code>的时候传入了参数<code>-1</code>, 你知道这是什么意思吗?</p></div></div>
<!-- -->
<div class="panel panel-info"><div class="panel-heading"><h5 class="panel-title" id="潜在的威胁-建议二周目思考"><i class="fa fa-question-circle"></i> 潜在的威胁 (建议二周目思考)</h5></div><div class="panel-body"><p>"调用<code>cpu_exec()</code>的时候传入了参数<code>-1</code>", 这一做法属于未定义行为吗?
请查阅C99手册确认你的想法.</p></div></div>
<p>不同的ISA有着不同的指令格式和含义, 因此执行指令的代码自然是ISA相关的.
这部分代码位于<code>nemu/src/isa/$ISA/inst.c</code>.
关于指令执行的详细说明需要涉及很多细节, 目前你无需关心, 我们将会在PA2中进行说明.</p>
<p>由于刚才我们运行NEMU的时候并未给出客户程序的镜像文件,
此时NEMU将会运行上文提到的内置客户程序.
NEMU将不断执行指令, 直到遇到以下情况之一, 才会退出指令执行的循环:</p>
<ul>
<li>达到要求的循环次数.</li>
<li>客户程序执行了<code>nemu_trap</code>指令. 这是一条虚构的特殊指令,
它是为了在NEMU中让客户程序指示执行的结束而加入的,
NEMU在ISA手册中选择了一些用于调试的指令, 并将<code>nemu_trap</code>的特殊含义赋予它们.
例如在riscv32的手册中, NEMU选择了<code>ebreak</code>指令来充当<code>nemu_trap</code>.
为了表示客户程序是否成功结束, <code>nemu_trap</code>指令还会接收一个表示结束状态的参数.
当客户程序执行了这条指令之后, NEMU将会根据这个结束状态参数来设置NEMU的结束状态,
并根据不同的状态输出不同的结束信息, 主要包括<ul>
<li><code>HIT GOOD TRAP</code> - 客户程序正确地结束执行</li>
<li><code>HIT BAD TRAP</code> - 客户程序错误地结束执行</li>
<li><code>ABORT</code> - 客户程序意外终止, 并未结束执行</li>
</ul>
</li>
</ul>
<p>当你看到NEMU输出类似以下的内容时(不同ISA的pc输出值会有所不同):</p>
<pre><code>nemu: HIT GOOD TRAP at pc = 0x8000000c
</code></pre><p>说明客户程序已经成功地结束运行.
NEMU会在<code>cpu_exec()</code>函数的最后打印执行的指令数目和花费的时间, 并计算出指令执行的频率.
但由于内置客户程序太小, 执行很快就结束了, 目前无法计算出有意义的频率,
将来运行一些复杂的程序时, 此处输出的频率可以用于粗略地衡量NEMU的性能.</p>
<p>退出<code>cpu_exec()</code>之后, NEMU将返回到<code>sdb_mainloop()</code>, 等待用户输入命令.
但为了再次运行程序, 你需要键入<code>q</code>退出NEMU, 然后重新运行.</p>
<div class="panel panel-info"><div class="panel-heading"><h5 class="panel-title" id="谁来指示程序的结束"><i class="fa fa-question-circle"></i> 谁来指示程序的结束?</h5></div><div class="panel-body"><p>在程序设计课上老师告诉你, 当程序执行到<code>main()</code>函数返回处的时候, 程序就退出了, 你对此深信不疑.
但你是否怀疑过, 凭什么程序执行到<code>main()</code>函数的返回处就结束了?
如果有人告诉你, 程序设计课上老师的说法是错的, 你有办法来证明/反驳吗?
如果你对此感兴趣, 请在互联网上搜索相关内容.</p></div></div>
<!-- -->
<div class="panel panel-info"><div class="panel-heading"><h5 class="panel-title" id="有始有终-建议二周目思考"><i class="fa fa-question-circle"></i> 有始有终 (建议二周目思考)</h5></div><div class="panel-body"><p>对于GNU/Linux上的一个程序, 怎么样才算开始? 怎么样才算是结束?
对于在NEMU中运行的程序, 问题的答案又是什么呢?</p><p>与此相关的问题还有: NEMU中为什么要有<code>nemu_trap</code>? 为什么要有monitor?</p></div></div>
<p>最后我们聊聊代码中一些值得注意的地方.</p>
<ul>
<li><p>三个对调试有用的宏(在<code>nemu/include/debug.h</code>中定义)</p>
<ul>
<li><code>Log()</code>是<code>printf()</code>的升级版, 专门用来输出调试信息, 同时还会输出使用<code>Log()</code>所在的源文件, 行号和函数.
当输出的调试信息过多的时候, 可以很方便地定位到代码中的相关位置</li>
<li><code>Assert()</code>是<code>assert()</code>的升级版, 当测试条件为假时, 在assertion fail之前可以输出一些信息</li>
<li><code>panic()</code>用于输出信息并结束程序, 相当于无条件的assertion fail</li>
</ul>
<p>代码中已经给出了使用这三个宏的例子, 如果你不知道如何使用它们, RTFSC.</p>
</li>
<li>内存通过在<code>nemu/src/memory/paddr.c</code>中定义的大数组<code>pmem</code>来模拟.
在客户程序运行的过程中, 总是使用<code>vaddr_read()</code>和<code>vaddr_write()</code>
(在<code>nemu/src/memory/vaddr.c</code>中定义)来访问模拟的内存.
vaddr, paddr分别代表虚拟地址和物理地址. 这些概念在将来才会用到,
目前不必深究, 但从现在开始保持接口的一致性可以在将来避免一些不必要的麻烦.</li>
</ul>
<div class="panel panel-warning"><div class="panel-heading"><h5 class="panel-title" id="理解框架代码"><i class="fa fa-edit"></i> 理解框架代码</h5></div><div class="panel-body"><p>你需要结合上述文字理解NEMU的框架代码.</p><p>如果你不知道"怎么才算是看懂了框架代码", 你可以先尝试进行后面的任务.
如果发现不知道如何下手, 再回来仔细阅读这一页面.
理解框架代码是一个螺旋上升的过程, 不同的阶段有不同的重点.
你不必因为看不懂某些细节而感到沮丧, 更不要试图一次把所有代码全部看明白.</p></div></div>
<!-- -->
<div class="panel panel-danger"><div class="panel-heading"><h5 class="panel-title" id="rtfsc--盯着代码看"><i class="fa fa-bullhorn"></i> RTFSC != 盯着代码看</h5></div><div class="panel-body"><p>你很可能是第一次接触到这么多源文件的项目, 看代码的时候可能会感到很迷茫:
不知道函数的定义在哪个文件, 不理解函数的功能是什么, 不清楚某段代码的行为具体如何...
同时你也很可能沿用以前看代码最原始的方式: 用眼睛看.
你坚持看了一段时间, 发现还是没什么收获, 于是你开始感到沮丧...</p><p>对于只有一两个源文件, 代码只有几百行的项目, 直接RTFSC还是有效果的.
但如果源文件更多, 代码量更大, 你很快就会发现这种做法效率很低,
这是因为人脑的短期记忆能力是很有限的, 即使是静态的代码也无法完全记得住,
更何况程序的动态行为是一个巨大的状态机, 你的大脑在一段时间内只能模拟出这个状态机很小的一部分.</p><p>有没有工具能够帮你模拟这个巨大的状态机呢?
这时我们在PA0里面提到的一个工具就派上用场了, 它就是GDB.
在GDB中, 我们可以通过单步执行的方式让程序一次执行一条指令,
相当于让状态机一次只前进一步, 这样我们就可以观察程序任意时刻的状态了!
而且状态机前进的轨迹就是程序执行的真实顺序, 于是你就可以一边运行程序一边理解程序的行为了.
这对于一些指针相关的代码有着不错的效果, 尤其是函数指针,
因为你从静态代码上很可能看不出来程序运行的时候这个指针会指向哪个函数.</p><p>GDB还自带一个叫TUI的简单界面. 在一个高度较高的窗口中运行GDB后,
输入<code>layout split</code>就可以切换到TUI, 这样你就可以同时从源代码和指令的角度来观察程序的行为了.
不过为了看到源代码, 你还需要在编译NEMU时添加GDB调试信息, 具体操作见下面的提示框.
如果你想了解TUI的更多内容, STFW.</p><p>为了帮助你更高效地RTFSC, 你最好通过RTFM和STFW多认识GDB的一些命令和操作, 比如:</p><ul>
<li>单步执行进入你感兴趣的函数</li>
<li>单步执行跳过你不感兴趣的函数(例如库函数)</li>
<li>运行到函数末尾</li>
<li>打印变量或寄存器的值</li>
<li>扫描内存</li>
<li>查看调用栈</li>
<li>设置断点</li>
<li>设置监视点</li>
</ul><p>如果你之前没有使用过GDB, 然后在PA0中又跳过了GDB相关的内容, 现在你就要吃偷懒的亏了.</p></div></div>
<!-- -->
<div class="panel panel-info"><div class="panel-heading"><h5 class="panel-title" id="为nemu编译时添加gdb调试信息"><i class="fa fa-edit"></i> 为NEMU编译时添加GDB调试信息</h5></div><div class="panel-body"><p>menuconfig已经为大家准备好相应选项了, 你只需要打开它:</p><pre><code>Build Options
  [*] Enable debug information
</code></pre><p>然后清除编译结果并重新编译即可.
尝试阅读相关代码, 理解开启上述menuconfig选项后会导致编译NEMU时的选项产生什么变化.</p></div></div>
<!-- -->
<div class="panel panel-warning"><div class="panel-heading"><h5 class="panel-title" id="优美地退出"><i class="fa fa-edit"></i> 优美地退出</h5></div><div class="panel-body"><p>为了测试大家是否已经理解框架代码, 我们给大家设置一个练习:
如果在运行NEMU之后直接键入<code>q</code>退出, 你会发现终端输出了一些错误信息.
请分析这个错误信息是什么原因造成的, 然后尝试在NEMU中修复它.</p></div></div>
<h3 id="就是这么简单">就是这么简单</h3>
<p>事实上, TRM的实现已经都蕴含在上述的介绍中了.</p>
<ul>
<li>存储器是个在<code>nemu/src/memory/paddr.c</code>中定义的大数组</li>
<li>PC和通用寄存器都在<code>nemu/src/isa/$ISA/include/isa-def.h</code>中的结构体中定义</li>
<li>加法器在... 嗯, 这部分框架代码有点复杂,
不过它并不影响我们对TRM的理解, 我们还是在PA2里面再介绍它吧</li>
<li>TRM的工作方式通过<code>cpu_exec()</code>和<code>exec_once()</code>体现</li>
</ul>
<p>在NEMU中, 我们只需要一些很基础的C语言知识就可以理解最简单的计算机的工作方式, 真应该感谢先驱啊.</p>
<footer class="page-footer-ex"> <span class="page-footer-ex-copyright"> By <a href="https://sashimi-yzh.github.io/" target="_blank">Zihao Yu</a>, 采用<a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" target="_blank">知识共享 署名-非商业性使用-相同方式共享 3.0 中国大陆 许可协议</a>发布 </span>            <span class="page-footer-ex-footer-update"> 此页面修订于:  2023-08-30 17:00:59 </span> </footer>
</section>
</div>
<div class="search-results">
<div class="has-results">
<h1 class="search-results-title"><span class="search-results-count"></span> results matching "<span class="search-query"></span>"</h1>
<ul class="search-results-list"></ul>
</div>
<div class="no-results">
<h1 class="search-results-title">No results matching "<span class="search-query"></span>"</h1>
</div>
</div>
</div>
</div>
</div>
</div>
<a aria-label="Previous page: 开天辟地的篇章" class="navigation navigation-prev" href="1.2.html">
<i class="fa fa-angle-left"></i>
</a>
<a aria-label="Next page: 基础设施" class="navigation navigation-next" href="1.4.html">
<i class="fa fa-angle-right"></i>
</a>
</div>
<script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"RTFSC","level":"1.3.3","depth":2,"next":{"title":"基础设施","level":"1.3.4","depth":2,"path":"1.4.md","ref":"1.4.md","articles":[]},"previous":{"title":"开天辟地的篇章","level":"1.3.2","depth":2,"path":"1.2.md","ref":"1.2.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"3.x.x","theme":"default","variables":{},"plugins":["theme-comscore","intopic-toc","localized-footer","page-footer-ex","callouts"],"pluginsConfig":{"callouts":{"option":{"alert":"info","picto":"fa-edit"},"flag":{"alert":"success","picto":"fa-flag"},"question":{"alert":"info","picto":"fa-question-circle"},"info":{"alert":"info","picto":"fa-info-circle"},"todo":{"alert":"warning","picto":"fa-edit"},"caution":{"alert":"danger","picto":"fa-bullhorn"},"danger":{"alert":"danger","picto":"fa-exclamation"},"showTypeInHeader":false},"intopic-toc":{"isCollapsed":false,"isScrollspyActive":true,"label":"导航","maxDepth":6,"mode":"nested","selector":".markdown-section h2, .markdown-section h3, .markdown-section h4","visible":true},"page-footer-ex":{"copyright":"By [Zihao Yu](https://sashimi-yzh.github.io/), 采用[知识共享 署名-非商业性使用-相同方式共享 3.0 中国大陆 许可协议](http://creativecommons.org/licenses/by-nc-sa/3.0/cn/)发布","markdown":true,"update_format":"YYYY-MM-DD HH:mm:ss","update_label":"此页面修订于: "},"search":{},"localized-footer":{"filename":"FOOTER.md","hline":"true"},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"theme":"white","family":"sans","size":2},"highlight":{},"theme-comscore":{},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles.css","pdf":"styles.css"}},"file":{"path":"1.3.md","mtime":"2023-08-30T09:00:59.197Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2023-12-05T03:26:43.464Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>
{% endblock %}